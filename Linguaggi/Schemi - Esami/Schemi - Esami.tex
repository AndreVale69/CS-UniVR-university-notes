\documentclass[a4paper]{article}
\usepackage[T1]{fontenc}			% pacchetto per \chapter
\usepackage[italian]{babel}
\usepackage[italian]{isodate}  		% formato delle date in italiano
\usepackage{graphicx}				% gestione delle immagini
\usepackage{amsfonts}
\usepackage{booktabs}				% tabelle di qualità superiore
\usepackage{amsmath}				% pacchetto matematica
\usepackage{mathtools}				% per sottolineare sotto le equazioni
\usepackage{stmaryrd} 				% per '\llbracket' e '\rrbracket'
\usepackage{amsthm}					% teoremi migliorati
\usepackage{enumitem}				% gestione delle liste
\usepackage{pifont}					% pacchetto con elenchi carini
\usepackage{enumitem}				% pacchetto per elenchi con lettere dell'alfabeto
\usepackage{cancel}					% per cancellare delle espressioni matematiche
\usepackage{caption}				% caption personalizzati
\usepackage[]{mdframed}				% box per il testo
\usepackage{multirow}				% più linee in una tabella
\usepackage{gensymb}				% simbolo di degree
\usepackage{listings}				% pacchetto per i codici

% draw a frame around given text
\newcommand{\framedtext}[1]{%
	\par%
	\noindent\fbox{%
		\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{#1}%
	}%
}



\usepackage[x11names]{xcolor}		% pacchetto colori RGB
% Link ipertestuali per l'indice
\usepackage{xcolor}
\usepackage[linkcolor=black, citecolor=blue, urlcolor=cyan]{hyperref}
\hypersetup{
	colorlinks=true
}

\usepackage{tikz}
\newcommand{\MyTikzmark}[2]{%
	\tikz[overlay,remember picture,baseline] \node [anchor=base] (#1) {#2};%
}
\newcommand{\DrawVLine}[3][]{%
	\begin{tikzpicture}[overlay,remember picture]
		\draw[shorten <=0.3ex, #1] (#2.north) -- (#3.south);
	\end{tikzpicture}
}
\newcommand{\DrawHLine}[3][]{%
	\begin{tikzpicture}[overlay,remember picture]
		\draw[shorten <=0.2em, #1] (#2.west) -- (#3.east);
	\end{tikzpicture}
}


%\usepackage{showframe}				% visualizzazione bordi
%\usepackage{showkeys}				% visualizzazione etichetta

\newtheorem{theorem}{\textcolor{Red3}{\underline{Teorema}}}
\newtheorem{lemma}{Lemma}
\renewcommand{\qedsymbol}{QED}
\newcommand{\exec}[1]{\llbracket #1\:\rrbracket}
\newcommand{\dquotes}[1]{``#1''}
\newcommand{\longline}{\noindent\rule{\textwidth}{0.4pt}}
\newcommand{\circledtext}[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt}{#1}}}}

\newenvironment{rowequmat}[1]{\left(\array{@{}#1@{}}}{\endarray\right)}
\newenvironment{rowequmatbra}[1]{\left[\array{@{}#1@{}}}{\endarray\right]}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}
	\author{VR443470}
	\title{Guida agli Esami di Linguaggi}
	\date{\printdayoff\today}
	\maketitle
	
	\newpage
	
	% indice
	\tableofcontents
	
	\newpage
	
	\section{Esercizio 1 - Domanda di teoria su Interprete e Compilatore}
	
	\subsection{Interprete}
	
	In molti esami si presenta la richiesta della definizione di interprete. Nonostante possa essere banale, viene richiesto un \dquotes{alto} livello di approfondimento dato che vale ben 4 punti all'interno dell'esame. In ogni caso, è possibile affermare che questa domanda sia una delle più gettonate.\newline
	
	\noindent
	\textcolor{Red3}{\textbf{\emph{Definire intuitivamente e formalmente (mediante definizione semantica) cosa è un interprete. Descrivere la struttura di un interprete e spiegarne il funzionamento.}}}\newline
	
	\noindent
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\newline
	
	\noindent
	La definizione intuitiva di un interprete è la seguente.
	
	Un \textbf{interprete} è un programma $\mathrm{int}^{L_{0}, L}$ che esegue, sulla macchina astratta per $L_{0}$, programmi $P^{L}$, i quali sono scritti nel linguaggio di programmazione $L$, su un input fissato appartenente all'insieme dei dati $D$ (input e output).\newline
	Utilizzando parole povere, un interprete non è altro che una \dquotes{macchina universale} che preso un programma e un suo input, esegue (il programma) sul quel determinato input usando \underline{soltanto} le funzionalità messe a disposizione dal livello (macchina astratta) sottostante.
	\begin{mdframed}
		\emph{Un attimo, ma che cosa si intende per livello? E macchina astratta?} Cerchiamo di fare chiarezza.\newline
		
		\noindent
		Dato un linguaggio di programmazione $L$, la \underline{macchina astratta} $M_{L}$ per $L$ è un insieme di strutture dati ed algoritmi che consentono di memorizzare ed eseguire programmi scritti in $L$. La sua realizzazione può essere fatta in Hardware, Firmware o Software.\newline
		
		\noindent
		\emph{Si ma quindi cosa si intende per livello?}\newline
		
		\noindent
		Con la scelta della categoria \dquotes{realizzazione software}, vengono utilizzati, per la realizzazione di strutture dati e algoritmi, linguaggi di programmazione ad alto livello poiché essi implementano una struttura suddivisa a \underline{livelli} di astrazione.\newline
		Per concludere, la macchina astratta può essere dunque vista come una stratificazione di livelli dove ciascuno di essi coopera in modo sequenziale, ma allo stesso tempo è indipendente.\newline
		
		\noindent
		Per non lasciare niente al caso, con \dquotes{\underline{linguaggio di programmazione ad alto} \underline{livello}} ci si riferisce a tutti quei linguaggi di programmazione che offrono un livello di astrazione molto alto dei dettagli del funzionamento del calcolatore.
	\end{mdframed}\newpage
	
	\noindent
	Prima della definizione formale di interprete, si illustrano due notazioni necessarie:
	\begin{itemize}
		\item Con il termine $Prog^{L}$ ci si riferisce all'insieme dei programmi scritti nel linguaggio di programmazione $L$;
		
		\item Con la dicitura:
		\begin{equation*}
			\exec{P^{L}} \: : \: D \rightarrow D
		\end{equation*}
		Si indica che l'esecuzione del programma scritto nel linguaggio di programmazione $L$ ($\exec{P^{L}}$) con input $in$ è uguale all'output $out$. Ovverosia:
		\begin{equation*}
			\exec{P^{L}}\left(in\right) = out	
		\end{equation*}
	\end{itemize}
	Un \textbf{interprete formalmente} è descrivibile nel seguente modo. Si consideri un interprete da $L$ a $L_{0}$: dato $P^{L} \in Prog^{L}$ e $in \in D$, un interprete $int^{L, L_{0}}$ per $L$ su $L_{0}$ è un programma tale che:
	\begin{equation*}
		\exec{int^{L, L_{0}}} \: : \: \left(Prog^{L}\right) \rightarrow D
	\end{equation*}
	Ne consegue che:
	\begin{equation*}
		\exec{int^{L, L_{0}}} \: : \: \left(P^{L}, in\right) = \exec{P^{L}}\left(in\right)
	\end{equation*}
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=\textwidth]{img/ex1-1.png}
		\caption*{Riassunto visivo di quanto appena descritto.}
	\end{figure}\newpage
	
	\noindent
	Qua di seguito si presenta il ciclo di esecuzione di un interprete:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=\textwidth]{img/ex1-2.png}
	\end{figure}
	\begin{enumerate}
		\item Il ciclo di esecuzione di un interprete si apre con l'acquisizione di un'istruzione da eseguire;
		
		\item L'operazione del passo precedente viene decodificata;
		
		\item Nel caso in cui l'operazione abbia bisogno di operandi, anch'essi vengono acquisiti dalla memoria;
		
		\item Data l'operazione acquisita al passo 1, viene selezionata una determinata operazione: nel caso di $OP_{...}$ si esegue un'operazione, nel caso di $HALT$ l'esecuzione di un interprete si ferma;
		
		\item Dopo l'operazione eseguita, se vi è un risultato, esso viene salvato. In ogni caso, il ciclo inizia nuovamente la sua esecuzione.
	\end{enumerate}
	
	\newpage
	\subsection{Compilatore}
	
	Non è frequente la richiesta della definizione di compilatore, ma rimane una domanda di teoria che può essere richiesta.\newline
	
	\noindent
	\textcolor{Red3}{\textbf{\emph{Definire intuitivamente e formalmente (mediante definizione semantica) cosa è un compilatore. Descrivere e spiegare poi la struttura di un compilatore (preferibilmente come flow-chart).}}}\newline
	
	\noindent
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\newline
	
	\noindent
	La definizione intuitiva di un compilatore è la seguente.
	
	Un \textbf{compilatore} è un programma $comp^{L_{0},L}$ che traduce, preservando semantica e funzionalità, programmi scritti nel linguaggio di programmazione $L$ in programmi scritti in $L_{0}$, e quindi eseguibili direttamente sulla macchina astratta per $L_{0}$.\newline
	
	\noindent
	Dato un linguaggio di programmazione $L$, una macchina astratta $M_{L}$ per $L$ è un insieme di strutture dati e algoritmi che consentono la memorizzazione e l'esecuzione dei programmi scritti nel linguaggio di programmazione $L$ ($P^{L}$).\newline
	
	\noindent
	Prima di dare la definizione formale di interprete, si forniscono alcune notazioni:
	\begin{itemize}
		\item $Prog^{L}$ è un insieme di programmi scritti nel linguaggio di programmazione $L$;
		\item $D$ è l'insieme dei dati (input e output);
		\item $P^{L}$ è il programma scritto nel linguaggio di programmazione $L$;
		\item $\exec{P^{L}} \: : \: D \rightarrow D$ rappresenta la semantica di $P^{L}$, ovvero l'esecuzione del programma nel linguaggio di programmazione $L$ con input $in$ è uguale all'output $out$:
		\begin{equation*}
			\exec{P^{L}}(in) = (out)
		\end{equation*}
	\end{itemize}
	La definizione formale di un compilatore è la seguente.
	
	Dato $P^{L} \in Prog^{L}$, un \textbf{compilatore formalmente} $comp^{L,L_{0}}$ da $L$ a $L_{0}$ è un programma che:
	\begin{equation*}
		\exec{comp^{L,L_{0}}}: Prog^{L} \rightarrow Prog^{L_{0}}
	\end{equation*}
	Ovvero:
	\begin{equation*}
		\exec{comp^{L,L_{0}}}\left(P^{L}\right) = \left(P^{L_{0}}\right) \hspace{1em} \text{tale che} \hspace{1em} \forall in \in D.\exec{P^{L_{0}}}\left(in\right) = \exec{P^{L}}\left(in\right)
	\end{equation*}
	In linguaggio non matematico, significa che l'esecuzione del compilatore da $L$ a $L_{0}$ insieme (input) ad un determinato programma scritto in un linguaggio di programmazione $L$ è uguale (output) al programma scritto nel linguaggio di programmazione $P^{L_{0}}$; tale che per ogni input $in$ appartenente all'insieme dei dati $D$, l'esecuzione di un programma scritto nel linguaggio di programmazione $L_{0}$ con input $in$ è uguale all'esecuzione del programma scritto nel linguaggio di programmazione $L$ con input $in$.\newpage
	
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=\textwidth]{img/ex1-3.png}
		\caption*{Flow-chart di quanto detto precedentemente.}
	\end{figure}
	
	\noindent
	Si presenta qua di seguito la \textbf{struttura di un compilatore}:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=\textwidth]{img/ex1-4.pdf}
	\end{figure}\newpage
	
	\begin{enumerate}
		\item Il programma sorgente, da compilare, passa in prima battuta da un analizzatore lessicale. Vengono \textbf{convertiti i caratteri del programma sorgente in unità lessicali}. Quest'ultime possono essere \emph{identificatori}, \emph{numeri}, \emph{parole riservate} e formano i linguaggi regolari.
		
		\item Le unità lessicali finiscono in un analizzatore sintattico, il quale crea una albero che rappresenta la sintassi del programma:
		\begin{itemize}
			\item Le foglie (\emph{token}) vengono lette da sinistra verso destra e costituiscono le frasi ben formate del linguaggio;
			
			\item Dal precedente punto, ne consegue che l'impossibilità della costruzione di un albero è dovuta all'illegalità di quale frase (mal formata, errore di compilazione!);
		\end{itemize}
		Quindi, l'\textbf{analizzatore sintattico trasforma unità lessicali in \emph{parse tree} (albero di parse) che rappresentano la struttura sintattica del programma}.
		
		\item Riceve informazioni dall'analizzatore lessicale/sintattico e \textbf{memorizza informazioni sui nomi presenti nel programma} (identificatori, chiamate di procedura, ecc.);
		
		\item A questo punto, viene \textbf{generato un codice intermedio} che è \emph{indipendente dall'architettura}, e vengono \textbf{rilevati eventuali errori semantici} grazie all'\emph{analizzatore semantico};
		
		\item (Opzionale) Il codice può essere ottimizzato in questa fase;
		
		\item Si conclude la struttura del compilatore con la generazione del codice macchina che, a differenza del codice intermedio, è dipendente dall'architettura.
	\end{enumerate}
	La parte finale dello schema mostra l'esecuzione del programma compilato su un computer con eventuali dati in input.\newpage
	
	\section{Esercizio 2 - Induzione}
	
	\subsection{Dimostrare $\forall n \in \mathbb{N}.n + n^{2}$ è un numero pari}
	
	\textcolor{Red3}{\textbf{\emph{Dimostrare per induzione che $\forall n \in \mathbb{N}.n + n^{2}$ è un numero pari.}}}\newline
	
	\noindent
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\newline
	
	\noindent	
	L'\textbf{induzione} è una tecnica di dimostrazione che consente di dimostrare la validità di una tesi dalla verifica di due condizioni: la validità della \dquotes{base induttiva} e la validità del \dquotes{passo induttivo}.
	\begin{proof}[\textbf{Caso base}]
		Si sceglie come caso base il valore $n = 1$. Si sostituisce:
		\begin{equation*}
			\begin{array}{rcl}
				n + n^{2} &\rightarrow& \text{ è pari? } \textcolor{Green4}{\checkmark} \\ [.3em]
				&\downarrow& \text{sostituzione di }n=1 \\ [.3em]
				1 + 1^{2} = 2 &\rightarrow& \text{ è pari? } \textcolor{Green4}{\checkmark}
			\end{array}
		\end{equation*}
		Utilizzando un linguaggio più formale, utile per la dimostrazione, è anche possibile affermare che il modulo di $n+n^{2}$ diviso $2$ è uguale a zero. Ovvero, che dividendo un numero pari per $2$ (per definizione), si ottiene il valore zero:
		\begin{equation*}
			\begin{array}{rcl}
				n+n^{2} &=& 0 \: \left(\mathrm{mod} \: 2\right) \\ [.3em]
				%
				&\downarrow& \text{sostituzione di }n=1 \\ [.3em]
				%
				1+1^{2} &=& 0 \: \left(\mathrm{mod} \: 2\right)
			\end{array}
		\end{equation*}
	\end{proof}
	
	\noindent
	\textbf{\emph{Ipotesi induttiva:}} si assume che sia vera:
	\begin{equation*}
		n+n^{2} = 0 \: \left(\mathrm{mod} \: 2\right) \hspace{1em} \forall n \in \mathbb{N}
	\end{equation*}
	
	\begin{proof}[\textbf{Passo induttivo}]
		Si dimostra che l'ipotesi induttiva implica la validità della proprietà per $n+1$:
		\begin{equation*}
			\begin{array}{rcl}
				n+n^{2} &=& 0 \: \left(\mathrm{mod} \: 2\right) \\ [.3em]
				%                                                       
				&\downarrow& \text{applico passo induttivo} \\ [.3em]    
				%
				n+1 + \left(n+1\right)^{2} &=& 0 \: \left(\mathrm{mod} \: 2\right) \\ [.3em]
				%
				n + 1 + n^{2} + 2n + 1 &=& 0  \: \left(\mathrm{mod} \: 2\right) \\ [.3em]
				%
				n^{2} + n + 2n + 2 &=& 0 \: \left(\mathrm{mod} \: 2\right) \\ [.3em]
				%
				&\downarrow& \text{applico l'ipotesi induttiva} \\ [.3em]
				%
				n^{2} + n + 2n + 2 &=& n^{2} + n \\ [.3em]
				%
				2n + 2 &=& 0 \: \left(\mathrm{mod} \: 2\right)
			\end{array}
		\end{equation*}
		Per definizione:
		\begin{itemize}
			\item Qualsiasi numero moltiplicato per $2$ si ottiene un numero pari;
			\item Il risultato tra la somma di due numeri pari è ancora un numero pari;
			\item $2$ è un numero pari.
		\end{itemize}
	\end{proof}\newpage
	
	\subsection{Dimostrare $\displaystyle\sum_{i=1}^{n}\dfrac{1}{i\left(i+1\right)} = \dfrac{n}{n+1}$}
	\textcolor{Red3}{\textbf{\emph{Dimostrare per induzione che }}$\displaystyle\sum_{i=1}^{n}\dfrac{1}{i\left(i+1\right)} = \dfrac{n}{n+1}$\textbf{\emph{.}}}\newline
	
	\noindent
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\newline
	
	\noindent
	L'\textbf{induzione} è una tecnica di dimostrazione che consente di dimostrare la validità di una tesi dalla verifica di due condizioni: la validità della \dquotes{base induttiva} e la validità del \dquotes{passo induttivo}.
	\begin{proof}[\textbf{Caso base}]
		Si sceglie come caso base il valore $n = 1$. Quindi, si va a sostituire:
		\begin{equation*}
			\begin{array}{rcl}
				\displaystyle\sum_{i=1}^{n}\dfrac{1}{i\left(i+1\right)} &=& \dfrac{n}{n+1} \\ [1.5em]
				%
				&\downarrow& \text{sostituzione }n=1 \\ [.5em]
				%
				\displaystyle\sum_{i=1}^{1}\dfrac{1}{i\left(i+1\right)} &=& \dfrac{1}{1+1} \\ [1.5em]
				%
				&\downarrow& \text{calcolo della sommatoria} \\ [.5em]
				%
				\displaystyle\sum_{i=1}^{1}\dfrac{1}{1\left(1+1\right)} &=& \dfrac{1}{1+1} \\ [1.5em]
				%
				\dfrac{1}{2} &=& \dfrac{1}{2}
			\end{array}
		\end{equation*}
	\end{proof}
	
	\noindent
	\textbf{\emph{Ipotesi induttiva:}} si assume che sia vera:
	\begin{equation*}
		\displaystyle\sum_{i=1}^{n}\dfrac{1}{i\left(i+1\right)} = \dfrac{n}{n+1} \hspace{2em} \forall n
	\end{equation*}
	
	\begin{proof}[\textbf{Passo induttivo}]
		Si dimostra che l'ipotesi induttiva implica la validità della proprietà per $n + 1$:
		\begin{equation*}
			\begin{array}{rcl}
				\displaystyle\sum_{i=1}^{n}\dfrac{1}{i\left(i+1\right)} &=& \dfrac{n}{n+1} \\ [1.5em]
				%
				&\downarrow& \text{applicazione passo induttivo} \\ [.5em]
				%
				\displaystyle\sum_{i=1}^{n+1}\dfrac{1}{i\left(i+1\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
				%
				\displaystyle\sum_{i=1}^{n}\dfrac{1}{i\left(i+1\right)} + \dfrac{1}{\left(n+1\right)\cdot\left(\left(n+1\right) + 1\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
			\end{array}
		\end{equation*}\newpage
		\begin{equation*}
			\begin{array}{rcl}
				&\downarrow& \text{utilizzo ipotesi induttiva} \\ [.5em]
				%
				\dfrac{n}{n+1} + \dfrac{1}{\left(n+1\right)\cdot\left(\left(n+1\right) + 1\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
				%
				\dfrac{n}{n+1} + \dfrac{1}{\left(n^{2} + 2n + 1\right) + \left(n+1\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
				%
				\dfrac{n}{n+1} + \dfrac{1}{\left(n+1\right)\left(n+2\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
				%
				\dfrac{n\left(n+2\right) + 1}{\left(n+1\right)\left(n+2\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
				%
				\dfrac{n^{2} + 2n + 1}{\left(n+1\right)\left(n+2\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
				%
				\dfrac{\left(n+1\right)^{2}}{\left(n+1\right)\left(n+2\right)} &=& \dfrac{n+1}{\left(n+1\right)+1} \\ [1.5em]
				%
				\dfrac{n+1}{n+2} &=& \dfrac{n+1}{n+2}
			\end{array}
		\end{equation*}
	\end{proof}\newpage
	
	\subsection{Dimostrare $\displaystyle\sum_{i=0}^{n} i^{2} = \dfrac{n\left(n+1\right)\left(2n+1\right)}{6}$}
	
	\textcolor{Red3}{\textbf{\emph{Dimostrare per induzione che }}$\displaystyle\sum_{i=0}^{n} i^{2} = \dfrac{n\left(n+1\right)\left(2n+1\right)}{6}$ \textbf{\emph{.}}}\newline
	
	\noindent
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\newline
	
	\noindent
	L'\textbf{induzione} è una tecnica di dimostrazione utilizzata per dimostrare la validità di una tesi grazie alla verifica di due condizioni: la validità della \dquotes{base induttiva} e la validità del \dquotes{passo induttivo}.
	
	\begin{proof}[\textbf{Caso base}]
		Scelgo come caso base il valore $n = 0$. La sua applicazione:
		\begin{equation*}
			\begin{array}{rcl}
				\displaystyle\sum_{i=0}^{n} i^{2} &=& \dfrac{n\left(n+1\right)\left(2n+1\right)}{6} \\ [1.5 em]
				%
				&\downarrow& \text{sostituisco }n=0 \\ [1.5em]
				%
				\displaystyle\sum_{i=0}^{0} 0^{2} &=& \dfrac{0\left(0+1\right)\left(2 \cdot 0+1\right)}{6} \\ [1.5 em]
				%
				0 &=& 0
			\end{array}
		\end{equation*}
	\end{proof}
	
	\noindent
	\textbf{\emph{Ipotesi induttiva:}} assumo che per $\forall n$ sia sempre vera la seguente proprietà:
	\begin{equation*}
		\displaystyle\sum_{i=0}^{n} i^{2} = \dfrac{n\left(n+1\right)\left(2n+1\right)}{6}
	\end{equation*}
	
	\begin{proof}[\textbf{Passo induttivo}]
		Si dimostra che l'ipotesi induttiva implica la veridicità della proprietà per $n+1$:
		\begin{equation*}
			\begin{array}{rcl}
				\displaystyle\sum_{i=0}^{n} i^{2} &=& \dfrac{n\left(n+1\right)\left(2n+1\right)}{6} \\ [1.5 em]
				%
				&\downarrow& \text{applico il passo induttivo} \\ [1.5em]
				%
				\displaystyle\sum_{i=0}^{n+1} i^{2} &=& \dfrac{\left(n+1\right)\left(\left(n+1\right)+1\right)\left(2 \left(n+1\right)+1\right)}{6} \\ [1.5 em]
				%
				\displaystyle\sum_{i=0}^{n} i^{2} + \left(n+1\right)^{2} &=& \dfrac{\left(n+1\right)\left(\left(n+1\right)+1\right)\left(2 \left(n+1\right)+1\right)}{6} \\ [1.5em]
				%
				&\downarrow& \text{applico l'ipotesi induttiva} \\ [1.5em]
				%
				\dfrac{n\left(n+1\right)\left(2n+1\right)}{6} + \left(n+1\right)^{2} &=& \dfrac{\left(n+1\right)\left(\left(n+1\right)+1\right)\left(2 \left(n+1\right)+1\right)}{6} \\ [1.5em]
				%
				\dfrac{n\left(n+1\right)\left(2n+1\right) + 6\left(n+1\right)^{2}}{6} &=& \dfrac{\left(n+1\right)\left(\left(n+1\right)+1\right)\left(2 \left(n+1\right)+1\right)}{6}
			\end{array}
		\end{equation*}\newpage
		\begin{equation*}
			\begin{array}{rcl}
				2n^{3} + n^{2} + 2n^{2} + n +6n^{2} + 12n + 6
				&=&
				\left(n^{2} + 3n + 2\right)\left(2n + 3\right) \\ [1.5em]
				%
				2n^{3} + 9n^{2} + 13n + 6 &=& 2n^{3} + 9n^{2} + 13n + 6
			\end{array}
		\end{equation*}
	\end{proof}\newpage
	
	\subsection{Dimostrare $\forall n \in \mathbb{N}. \: n > 2$ si ha che $n^{2} > 2n + 1$}
	
	\textcolor{Red3}{\textbf{\emph{Dimostrare per induzione che }}$\forall n \in \mathbb{N}. \: n > 2$ \textbf{\emph{si ha che}} $n^{2} > 2n + 1$ \textbf{\emph{.}}}\newline
	
	\noindent
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\footnote{Fonte soluzione: \href{https://youtu.be/2GycaLOF1no}{YouTube Link}}\newline
	
	\noindent
	L'\textbf{induzione} è una tecnica di dimostrazione utilizzata per dimostrare la validità di una tesi tramite la verifica di due condizioni: la validità del \dquotes{passo base} e la validità del \dquotes{passo induttivo}.
	
	\begin{proof}[\textbf{Caso base}]
		Si sceglie come caso base $n = 3$, rispettando la condizione $n > 2$:
		\begin{equation*}
			\begin{array}{rcl}
				n^{2} &>& 2n + 1 \\ [.3em]
				&\downarrow& \text{sostituisco }n=3 \\ [.3em]
				3^{2} &>& 2 \cdot 3 + 1 \\ [.3em]
				9 &>& 7
			\end{array}
		\end{equation*}
	\end{proof}
	
	\noindent
	\textbf{\emph{Ipotesi induttiva:}} si assume per vero che $\forall n \in \mathbb{N}.n>2$ allora si ha $n^{2} > 2n + 1$ o equivalentemente, con qualche manipolazione algebrica $n^{2} -2n -1 > 0$.
	
	\begin{proof}[\textbf{Passo induttivo}]
		Si dimostra che l'ipotesi induttiva implica la veridicità della proprietà per $n + 1$:
		\begin{equation*}
			\begin{array}{rcl}
				n^{2} &>& 2n + 1 \\ [.3em]
				&\downarrow& \text{applico il passo induttivo} \\ [.3em]
				\left(n+1\right)^{2} &>& 2 \left(n+1\right) + 1 \\ [.3em]
				n^{2} + 2n + 1 &>& 2n +2 +1 \\ [.3em]
				n^{2} + 2n + 1 -2n -2 -1 &>& 0 \\ [.3em]
				n^{2} -2n -1 + 2n + 1 -2 &>& 0 \\ [.3em]
				n^{2} -2n -1 + 2n -1 &>& 0 \\ [.3em]
				&\downarrow& \text{applico l'ipotesi induttiva} \\[.3em]
				n^{2} -2n -1 &>& 0 +2n -1 > 0 \\ [.3em]
				&\downarrow& \text{per } n > 2 \Rightarrow 2n-1 \text{ sarà sempre positiva e } >0 \\ [.3em]
				n^{2} -2n -1 &>& 0
			\end{array}
		\end{equation*}
	\end{proof}\newpage
	
	\section{Esercizio 3 - Scoping statico e dinamico}
	
	\subsection{Tipologia codice 1}
	
	\textcolor{Red3}{\textbf{\emph{Si consideri il programma sulla destra. Si dica cosa viene calcolato dall'assegnamento in caso di scoping statico (mostrando come vengono calcolati i link statici e come vengono risolti riferimenti non locali) e in caso di scoping dinamico (mostrando l'evoluzione della tabella centrale dei riferimenti (CRT) e come vengono risolti riferimenti non locali).}}}
	\lstinputlisting[language=C]{code/ex3-1.c}
	
	\noindent
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\newline
	
	\noindent
	Esistono \textbf{due tipologie} di scope:
	\begin{itemize}
		\item Scope \textbf{statico}, in cui un \textbf{nome non locale è risolto nel blocco} che testualmente lo racchiude;
		\item Scope \textbf{dinamico}, in cui un \textbf{nome non locale è risolto nella chiamata} attivata \textbf{più di recente} e \textbf{non ancora terminata}.
	\end{itemize}
	La \textbf{tabella centrale dei riferimenti} si riferisce allo scope dinamico. Quest'ultimo, a livello pratico, può essere implementano con una tecnica chiamata Shallow Access, nella quale le variabili locali sono poste in delle strutture dati centrali. Ed ecco che entra in gioco la CRT, una tabella con le seguenti \textbf{caratteristiche}:
	\begin{itemize}
		\item Una \textbf{entry per ogni variabile} nel programma;
		\item Ogni entry ha un \textbf{puntatore ad una lista di elementi};
		\item Ogni lista di elementi contiene \textbf{informazioni} necessarie per \textbf{accedere} ad un eventuale \textbf{ambiente di riferimento}.
	\end{itemize}
	Si inizia con l'analisi del codice e l'applicazione dello scoping statico/dinamico.\newpage
	
	\begin{center}
		\textbf{\emph{\underline{Scoping statico}}}
	\end{center}
	\textbf{\emph{Passo 1:}} si calcola la profondità del codice dato. Si indica con $Sd$ la profondità statica, ovvero la profondità di annidamento della definizione della procedura corrispondente al RdA (record di attivazione, i.e. stack/pila).\newline
	
	\noindent
	\begin{minipage}{.7\textwidth}
		\begin{center}
			\includegraphics[width=\textwidth]{img/ex3-1.pdf}
		\end{center}
	\end{minipage}
	\begin{minipage}{.3\textwidth}
		\begin{equation*}
			\begin{array}{rcl}
				Sd\left(main\right) &=& 0 \\
				Sd\left(pippo\right) &=& 1 \\
				Sd\left(pluto\right) &=& 1 \\
				Sd\left(minnie\right) &=& 2 \\
			\end{array}
		\end{equation*}
	\end{minipage}\newline
	
	\noindent
	\textbf{\emph{Passo 2:}} si procede con l'esecuzione del codice, calcolando, ad ogni chiamata, i link statici e mostrando come vengono risolti i riferimenti non locali. Si ricorda che la formula per calcolare i link statici è:
	\begin{equation*}
		k = Sd(Ch) - Sd(P) + 1
	\end{equation*}
	Un link dinamico punta sempre al chiamante, così da formare la catena dinamica, mentre un link statico dipende dalla formula soprastante.
	
	La profondità statica (Sd, \emph{static deep}) del chiamante $Ch$, meno la profondità statica del chiamato, cioè la procedura $P$, più uno. Inoltre, la formula per calcolare i riferimenti non locali è:
	\begin{equation*}
		N = Sd(P) - Sd(D)
	\end{equation*}
	Numero di volte necessario per risalire la catena statica è dato dalla differenza tra la profondità statica della procedura in cui viene utilizzato l'identificatore ($Sd(P)$), meno la profondità statica della procedura $D$ che definisce tale identificatore ($Sd(D)$).
	
	Infine, con $CS$ si indica l'abbreviazione di Catena Statica, ovvero la catena di link statici che collegano le istanze del RdA.\newpage
	\begin{enumerate}
		\item $\mathbf{main}$ invoca la funzione $\mathbf{pluto}$.
		\begin{equation*}
			\begin{array}{rcl}
				\text{Link statico} &\rightarrow& Sd(main) - Sd(pluto) + 1 = 0 - 1 + 1 = 0 \\ [.3em]
				&\Rightarrow& CS\left(pluto\right) = indirizzo\left(main\right) \\ [.3em]
				\text{Riferimento non locale }a &\rightarrow& N = Sd(pluto) - Sd(main) = 1 - 0 = 1
			\end{array}
		\end{equation*}
		\begin{figure}[!htp]
			\centering
			\includegraphics[width=.6\textwidth]{img/ex3-2.pdf}
			\caption*{Evoluzione della memoria.}
		\end{figure}\newpage
		
		\item $\mathbf{pluto}$ invoca la funzione $\mathbf{pippo}$.
		\begin{equation*}
			\begin{array}{rcl}
				\text{Link statico} &\rightarrow& Sd(pluto) - Sd(pippo) + 1 = 1 - 1 + 1 = 1 \\ [.3em]
				&\Rightarrow& CS(pippo) = indirizzo(CS(pluto)) \\ [.3em]
				& &\phantom{ CS(pippo) }= indrizzo(main) \\ [.3em]
				\text{Riferimento non locale }a &\rightarrow& Sd(pippo) - Sd(main) = 1 - 0 = 1
			\end{array}
		\end{equation*}
		\begin{figure}[!htp]
			\centering
			\includegraphics[width=.6\textwidth]{img/ex3-3.pdf}
			\caption*{Evoluzione della memoria.}
		\end{figure}\newpage
		
		\item $\mathbf{pluto}$ invoca la funzione $\mathbf{minnie}$.
		\begin{equation*}
			\begin{array}{rcl}
				\text{Link statico} &\rightarrow& Sd(pluto) - Sd(minnie) + 1 = 1 - 2 + 1 = 0 \\ [.3em]
				&\Rightarrow& CS(minnie) = indirizzo(pluto) \\ [.3em]
				\text{Riferimento non locale} &\rightarrow& \text{nessuno}
			\end{array}
		\end{equation*}
		\begin{figure}[!htp]
			\centering
			\includegraphics[width=.6\textwidth]{img/ex3-4.pdf}
			\caption*{Evoluzione della memoria.}
		\end{figure}\newpage
		
		\item $\mathbf{minnie}$ invoca la funzione $\mathbf{pippo}$.
		\begin{equation*}
			\begin{array}{rcl}
				\text{Link statico} &\rightarrow& Sd(minnie) - Sd(pippo) + 1 = 2 - 1 + 1 = 2 \\ [.3em]
				&\Rightarrow& CS(pippo) = indirizzo(CS(CS(minnie))) \\ [.3em]
				&&\phantom{ CS(pippo) } = indirizzo(CS(pluto)) \\ [.3em]
				&&\phantom{ CS(pippo) } = indirizzo(main) \\ [.3em]
				\text{Riferimento non locale }a &\rightarrow& N = Sd(pippo) - Sd(main) = 1-0 = 1
			\end{array}
		\end{equation*}
		\begin{figure}[!htp]
			\centering
			\includegraphics[width=.6\textwidth]{img/ex3-5.pdf}
			\caption*{Evoluzione della memoria.}
		\end{figure}
	\end{enumerate}\newpage
	
	\begin{center}
		\textbf{\emph{\underline{Scope dinamico}}}
	\end{center}
	
	\noindent
	Ogni \underline{aggiornamento} della tabella, ovvero ogni aggiornamento della lista di elementi per gli identificatori, viene eseguita inserendo in cima l'ultima dichiarazione eseguita.\newline
	
	\noindent
	\textbf{Chiamata principale del \emph{main}}. Variabile inizializzata a 2 e poi aggiornata al valore 3:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.5\textwidth]{img/ex3-6.pdf}
	\end{figure}
	
	\noindent
	$\mathbf{main}$\textbf{ invoca }$\mathbf{pluto}$. Aggiornamento del valore della variabile $a$ con il valore 3:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.5\textwidth]{img/ex3-7.pdf}
	\end{figure}
	
	\noindent
	$\mathbf{pluto}$\textbf{ invoca }$\mathbf{pippo}$. Incremento di $1$ del valore della variabile $a$, quindi $1+1 = 2$:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.5\textwidth]{img/ex3-8.pdf}
	\end{figure}
	
	\noindent
	Ritorno da $\mathbf{pippo}$:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.5\textwidth]{img/ex3-9.pdf}
	\end{figure}\newpage
	
	\noindent
	$\mathbf{pluto}$\textbf{ invoca }$\mathbf{minnie}$. Il parametro $b$ assume il valore $3$, viene aggiornata la lista degli elementi per l'identificatore $a$ inserendo la moltiplicazione tra $b$ e $2$, cioè $2 \times b = 2 \times 3 = 6$:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.8\textwidth]{img/ex3-010.pdf}
	\end{figure}
	
	\noindent
	$\mathbf{minnie}$\textbf{ invoca }$\mathbf{pippo}$. Ancora una volta, $pippo$ incrementa la variabile $a$, la quale si riferisce al $main$:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.8\textwidth]{img/ex3-011.pdf}
	\end{figure}
	
	\noindent
	Ritorno da $\mathbf{pippo}$:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.8\textwidth]{img/ex3-012.pdf}
	\end{figure}
	
	\noindent
	Ritorno da $\mathbf{minnie}$. Vengono rimossi gli elementi $a,b$ che si riferiscono a $minnie$ poiché la chiamata è stata conclusa:
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.5\textwidth]{img/ex3-013.pdf}
	\end{figure}
	
	\noindent
	La CRT dopo il ritorno da $\mathbf{pluto}$ è identico alla figura soprastante.
	
	\newpage
	
	% 2023-02-01
	% 2022-09-19
	% 2022-09-19
	% 2020-02-03
	
	\subsection{Tipologia codice 2}
	
	% 2022-02-24
	\newpage
	
	\subsection{Tipologia codice 3}
	
	% 2021-07-13
	\newpage
	
	\subsection{Tipologia codice 4}
	
	% 2021-02-25
	% 2020-02-20
	\newpage
	
	\subsection{Tipologia codice 5}
	
	% 2021-02-08
	\newpage
	
	\subsection{Tipologia codice 6}
	
	% 2020-09-24
	\newpage
	
	\subsection{Tipologia codice 7}
	
	% 2020-09-24
	\newpage
	
	\subsection{Tipologia codice 8}
	
	% 2020-02-04
	\newpage
	
	\subsection{Tipologia codice 9}
	% 2023-06-28
	\textcolor{Red3}{\textbf{\emph{Si consideri il programma sulla destra. Si dica cosa viene calcolato dall'assegnamento in caso di scoping statico (mostrando come vengono calcolati i link statici e come vengono risolti riferimenti non locali) e in caso di scoping dinamico (mostrando l'evoluzione della tabella centrale dei riferimenti (CRT) e come vengono risolti riferimenti non locali).}}}
	\lstinputlisting[language=C]{code/ex3-9.c}
	\textcolor{Green4}{\textbf{\emph{\underline{Risposta}}}}\newline
	
	\noindent
	Esistono due tipologie di scoping:
	\begin{itemize}
		\item Statico, in cui un nome non locale è risolto nel blocco che lo racchiude;
		
		\item Dinamico, in cui un nome non locale è risolto nella chiamata attivata più di recente e non ancora terminata.
	\end{itemize}
	La tabella centrale dei riferimenti (CRT) si riferisce allo scope dinamico. Quest'ultimo può essere implementato, a livello pratico, tramite una tecnica chiamata Shallow Access. Essa consente di avere una struttura dati centrale contenente le variabili locali. Dunque, la tabella CRT ha tre caratteristiche principali:
	\begin{itemize}
		\item Ogni entry corrisponde ad una variabile nel programma;
		
		\item Ogni entry ha un puntatore ad una lista di elementi;
		
		\item Ogni lista di elementi contiene informazioni necessarie ad accedere ad un eventuale ambiente di riferimento
	\end{itemize}\newpage
	
	\begin{center}
		\textbf{\emph{\underline{Scoping statico}}}
	\end{center}
	
	\noindent
	\textbf{\emph{Passo 1:}} si calcola la profondità statica ($Sd$, Static deep) di ciascuna funzione presente all'interno del programma. La profondità statica indica la profondità di annidamento della definizione della procedura corrispondente al Record di Attivazione (RdA), i.e. Stack/Pila).\newline
	
	\noindent
	\begin{minipage}{.7\textwidth}
		\begin{center}
			\includegraphics[width=\textwidth]{img/ex3-014.pdf}
		\end{center}
	\end{minipage}
	\begin{minipage}{.3\textwidth}
		\begin{equation*}
			\begin{array}{rcl}
				Sd\left(main\right) &=& 0 \\
				Sd\left(fun\right) &=& 1 \\
				Sd\left(fun2\right) &=& 1 \\
				Sd\left(fun3\right) &=& 2 \\
			\end{array}
		\end{equation*}
	\end{minipage}\newline
	
	\noindent
	\textbf{\emph{Passo 2:}} si inizia ad analizzare il codice. Come richiesto dall'esercizio, si espone il calcolo dei link statici:
	\begin{equation*}
		k = Sd(Ch) - Sd(P) + 1
	\end{equation*}
	Con $Sd(Ch)$ che rappresenta la profondità statica del chiamante, $Sd(P)$ la profondità statica del programma invocato e $k$ la profondità (def. di \emph{static deep}). L'insieme dei link statici forma una catena statica (CS), ovvero un collegamento delle varie istanze del RdA. Al contrario, i link dinamici (DL, \emph{dynamic link}) puntano sempre al chiamante e formano la catena dinamica;\newline
	Il calcolo di eventuali riferimenti non locali:
	\begin{equation*}
		N = Sd(P) - Sd(D)
	\end{equation*}
	Con $Sd(P)$ che rappresenta la profondità statica della procedura che sta utilizzando il riferimento non locale, $Sd(D)$ che rappresenta la profondità statica della procedura in cui è stato definito il riferimento, $N$ che rappresenta il numero di volte necessarie per risalire la catena statica.\newpage
	
	\noindent
	$\mathbf{main}$ invoca la funzione $\mathbf{fun2}$.
	\begin{equation*}
		\begin{array}{rcl}
			\text{Link statico} &\rightarrow& Sd(main) - Sd(fun2) + 1 = 0 - 1 + 1 = 0 \\ [.3em]
			&\Rightarrow& CS(pluto) = indirizzo(main) \\ [.3em]
			\text{Riferimento non locale }b &\rightarrow& N = Sd(fun2) - Sd(main) = 1 - 0 = 1
		\end{array}
	\end{equation*}
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=\textwidth]{img/ex3-015.pdf}
	\end{figure}\newpage
	
	$\mathbf{fun2}$ invoca la funzione $\mathbf{fun3}$.
	\begin{equation*}
		\begin{array}{rcl}
			\text{Link statico} &\rightarrow& Sd(fun2) - Sd(fun3) + 1 = 1 - 2 + 1 = 0 \\ [.3em]
			&\Rightarrow& CS(fun3) = indirizzo(fun2) \\ [.3em]
			\text{Riferimento non locale }c &\rightarrow& N = Sd(fun3) - Sd(fun2) = 2 - 1 = 1 \\ [.3em]
			\text{Riferimento non locale }b &\rightarrow& N = Sd(fun3) - Sd(main) = 2 - 0 = 2
		\end{array}
	\end{equation*}
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=.6\textwidth]{img/ex3-016.pdf}
	\end{figure}
	
	\section{Esercizio 4 - Scoping (statico/dinamico) e Binding}
	
	\subsection{Regole di scoping e di binding}
	
	\subsection{Codice da inserire in caso di scoping statico/dinamico}
	
	\subsubsection{Tipologia di codice 1}
	% 2022-02-24
	
	\subsubsection{Tipologia di codice 2}
	% 2023-06-28
	% 2020-02-20
	
	\subsubsection{Tipologia di codice 3}
	% 2020-09-24
	% 2020-02-24
	
	\section{Esercizio 5 - Ricorsione e passaggio di parametri}
	
	\subsection{Ricorsione e ricorsione in coda}
	
	\subsection{Passaggio di parametri: per valore e per riferimento}
	
	\subsubsection{Tipologia di codice 1}
	% 2023-06-28
	
	\subsubsection{Tipologia di codice 2}
	% 2023-02-01
	
	\subsubsection{Tipologia di codice 3}
	% 2021-02-08
	
	\subsubsection{Tipologia di codice 4}
	% 2020-02-04
	
	\section{Esercizio 6 - Regole della semantica dinamica}
	
	\subsection{Derivazioni semantica dinamica}
	
	\subsubsection{Tipologia di memoria 1}
	% 2023-06-28
	
	\subsubsection{Tipologia di memoria 2}
	% 2023-02-01
	% 2022-09-19
	% 2022-02-03
	
	\subsubsection{Tipologia di memoria 3}
	% 2021-02-08
	
	\subsubsection{Vecchi esercizi}
	% 2020-02-20
	% 2020-09-24
	% 2020-02-04
	
	\subsection{Regole della semantica dinamica per il comando condizionale}
	
	% 2022-02-24
	% 2021-02-25
	
	\subsection{Regole della semantica dinamica per l'assegnamento}
	
	% 2021-07-13
\end{document}