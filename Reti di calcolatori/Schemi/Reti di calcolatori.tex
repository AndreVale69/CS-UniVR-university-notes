\documentclass[a4paper]{article}
\usepackage[italian]{babel}
\usepackage[italian]{isodate}  		% formato delle date in italiano
\usepackage{graphicx}				% gestione delle immagini
\usepackage{amsfonts}
\usepackage{booktabs}				% tabelle di qualità superiore
\usepackage{amsmath}				% pacchetto matematica
\usepackage{enumitem}				% gestione delle liste
\usepackage{pifont}					% pacchetto con elenchi carini
\usepackage[x11names]{xcolor}		% colori aggiuntivi
% Link ipertestuali per l'indice
\usepackage{xcolor}
\usepackage[linkcolor=black, citecolor=blue, urlcolor=cyan]{hyperref}
\hypersetup{
	colorlinks=true
}

\newcommand{\dquotes}[1]{``#1''}
\newcommand{\binaryaddress}[4]{#1 \hspace{1em} #2 \hspace{1em} #3 \hspace{1em} #4}
\newcommand{\binaryaddresspointed}[4]{#1\:.\:#2\:.\:#3\:.\:#4}

%\usepackage{showframe}				% visualizzazione bordi
%\usepackage{showkeys}				% visualizzazione etichetta

\begin{document}
	\author{VR443470}
	\title{Reti di calcolatori}
	\date{\printdayoff\today}
	\maketitle
	
	\newpage
	
	% indice
	\tableofcontents
	
	\newpage
	
	%%%%%%%%%%%%%%%%
	% Introduzione %
	%%%%%%%%%%%%%%%%
	\section{Introduzione}
	
	\textbf{Internet} è una rete di calcolatori che interconnette miliardi di dispositivi di calcolo in tutto il mondo. Gli strumenti in una rete, per esempio cellulari o computer, vengono chiamati \textbf{host} (\emph{ospiti}) o \textbf{sistemi periferici} (\emph{end system}). Essi sono connessi tra di loro tramite una \textbf{rete di collegamenti} (\emph{communication link}) e \textbf{commutatori di pacchetti} (\emph{packet switch}). I collegamenti possono essere di vario tipo: cavi coassiali, fili di rame, fibre ottiche e onde elettromagnetiche. \newline
	Ogni collegamento detiene una sua \textbf{velocità di trasmissione} (\emph{transmission rate}), ovvero la velocità di trasmissione dei dati. L’\textbf{unità di misura} è il bit per secondo (bit/secondo, \emph{bps}).
	
	L’insieme delle informazioni, o dati, che vengono inviati o ricevuti prendono il nome di \textbf{pacchetto}. L’\textbf{obbiettivo} \underline{di un commutatore di pacchetti} è quello di ricevere un pacchetto che arriva da un collegamento in ingresso e di ritrasmetterlo su un collegamento d’uscita. I due \underline{principali commutatori} di internet sono: \emph{router} e i commutatori a livello di collegamento (\emph{link-layer switch}). La sequenza di collegamenti e di commutatori di pacchetto attraversata dal singolo pacchetto è nota come \textbf{percorso} o \textbf{cammino} (\emph{route} o \emph{path}).
	
	Quindi, in sintesi, le definizioni più rilevanti sono:
	
	\begin{itemize}
		\item[\ding{42}] \textcolor{Red3}{\textbf{Internet.}} Rete di calcolatori che interconnette i dispositivi di calcolo di tutto il mondo.
		
		\item[\ding{42}] \textcolor{Red3}{\textbf{Host (\emph{o} sistemi periferici).}} Strumenti in una rete, per esempio computer.
		
		\item[\ding{42}] \textcolor{Red3}{\textbf{Rete di collegamenti (\emph{communication link}) e commutatori di pacchetto (\emph{packet switch}).}} Collega vari \emph{host}, per esempio cavi coassiali o fili di rame.
		
		\item[\ding{42}] \textcolor{Red3}{\textbf{Velocità di trasmissione (\emph{transmission rate})}}. È la velocità di trasmissione dei dati e solitamente la sua \textbf{unità di misura} è il bit per secondo, cioè \emph{bps}.
		
		\item[\ding{42}] \textcolor{Red3}{\textbf{Pacchetto.}} Insieme delle informazioni che vengono inviate e ricevute.
		
		\item[\ding{42}] \textcolor{Red3}{\textbf{\underline{Obbiettivo}} commutatore di pacchetti.} Ricevere un pacchetto proveniente da un collegamento in ingresso e ritrasmetterlo su un collegamento d'uscita. Per esempio i \emph{router}.
		
		\item[\ding{42}] \textcolor{Red3}{\textbf{Percorso (\emph{route}) o cammino (\emph{path}).}} Sequenza di collegamenti e di commutatori di pacchetto attraversata dal singolo pacchetto.
	\end{itemize}

	\newpage
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% ISP, TCP/IP, commutazione dei pacchetti e ritardi %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{ISP, TCP/IP, commutazione dei pacchetti e ritardi}
	
	\subsection{ISP}
	
	I sistemi periferici accedono ad Internet tramite un servizio chiamato \textbf{Internet Service Provider} (ISP). Con \textbf{provider} si intende un insieme di commutatori di pacchetto e di collegamenti. Gli \textbf{obbiettivi} degli ISP è fornire ai sistemi periferici svariati tipi di accesso alla rete, come quello residenziale a larga banda (e.g. DSL), quello in rete locale ad alta velocità, quello senza fili (\emph{wireless}) e in mobilità.
	
	\noindent
	Esistono \textbf{$3$ tipi} di livelli di ISP:
	
	\begin{description}
		\item{\textbf{Livello 1.}} \emph{Internazionale} (Telecom, TIM, ...);
		\item{\textbf{Livello 2.}} \emph{Nazionale} (Fastweb);
		\item{\textbf{Livello 3.}} \emph{Locale} (solitamente per professionisti).
	\end{description}

	Più è basso il livello, più gli ISP sono costituiti da \emph{router} ad alta velocità interconnessi tipicamente tramite fibra ottica.
	
	\subsection{TCP/IP}
	
	I sistemi periferici, i commutatori di pacchetto e altre parti di Internet fanno uso di \textbf{protocolli} che controllano l’invio e la ricezione di informazioni all’interno della rete. Esistono \textbf{due principali protocolli} Internet: \textbf{\emph{Transmission Control Protocol}} (TCP) e \textbf{\emph{Internet Protocol}} (IP). In particolare, l’IP specifica il formato dei pacchetti scambiati tra router e sistemi periferici. Generalmente ci si riferisce a questi due protocolli tramite il nome collettivo TCP/IP.
	
	\newpage
	
	\subsection{Commutazione dei pacchetti}
	
	Esistono due diversi approcci per spostare quantità di dati all’interno di una rete: la \textbf{commutazione di circuito} e la \textbf{commutazione di pacchetto}.
	
	\begin{center}
		\large \textcolor{Red3}{\textbf{Commutazione di circuito}}
	\end{center}
	
	Nella \textbf{commutazione di circuito} le risorse richieste lungo un percorso (buffer e velocità di trasmissione sui collegamenti) sono \textbf{riservate} per l'intera durata della sessione di comunicazione.
	
	\noindent
	\textcolor{Green4}{\textbf{Vantaggi:}}
	
	\begin{itemize}
		\item[\ding{51}] \textbf{Velocità costante} durante il collegamento poiché le risorse sono riservate e non condivise. Questo si traduce in un \textbf{ritardo contenuto}.
	\end{itemize}

	\noindent
	\textcolor{Red1}{\textbf{Svantaggi:}}
	
	\begin{itemize}
			\item[\ding{55}] \textbf{Spreco di risorse} poiché i circuiti sono inattivi durante i periodi di silenzio, ovvero nei periodi in cui non c’è comunicazione;
			
			\item[\ding{55}] \textbf{Complicazioni} nello stabilire circuiti e nel riservare larghezza di banda \emph{end-to-end}.
	\end{itemize}

	In questo contesto, i ritardi possono essere causati solamente per tre motivi: (1) a causa dell'instaurazione del circuito, (2) a causa della distanza tra sorgente e destinazione, (3) a causa della trasmissione vera e propria.
	
	\begin{center}
		\large \textcolor{Red3}{\textbf{Commutazione di pacchetto}}
	\end{center}

	Nella \textbf{commutazione di pacchetto} la sorgente divide i messaggi in parti più piccole, ovvero in \textbf{pacchetti} assegnando a ciascuno un'intestazione. I pacchetti viaggiano attraverso collegamenti e commutatori di pacchetto dalla sorgente alla destinazione.
	
	\noindent
	\textcolor{Green4}{\textbf{Vantaggi:}}
	
	\begin{itemize}
		\item[\ding{51}] \textbf{Ottimizzazione} delle risorse poiché c’è una condivisione di esse nei momenti di inattività.
	\end{itemize}
	
	\noindent
	\textcolor{Red1}{\textbf{Svantaggi:}}
	
	\begin{itemize}
		\item[\ding{55}] \textbf{Possibile perdita} di pacchetti nel caso in cui un buffer di un nodo sia saturo. Questo comporta un buffer overflow e una conseguente perdita;
		
		\item[\ding{55}] \textbf{Ritardo dovuto a \emph{store and forward} e numero di nodi intermedi.} A causa dello \emph{store and forward}, ogni nodo deve attendere di ricevere l'intero pacchetto prima di ritrasmetterlo. Inoltre, con l'aumentare dei nodi intermedi, il ritardo aumenta.\newline
		(approfondimento \href{https://it.wikipedia.org/wiki/Store_and_forward#:~:text=Nelle%20telecomunicazioni%2C%20lo%20store%20and,ritrasmesso%20nel%20collegamento%20in%20uscita}{\emph{store and forward}})
	\end{itemize}
	
	\newpage
	
	\subsection{Tipologie di ritardi}
	
	Esistono diverse tipologie di ritardo perché quando un pacchetto parte da un \emph{host} (sorgente), passa attraverso una serie di \emph{router} e conclude il viaggio in un altro \emph{host} (destinazione). Questo comporta un ritardo in ciascun nodo (\emph{host} o \emph{router}). I principali ritardi sono: \textbf{ritardo di elaborazione}, \textbf{ritardo di accodamento}, \textbf{ritardo di trasmissione} e \textbf{ritardo di propagazione}. L'insieme di questi ritardi è chiamato \textbf{ritardo totale di nodo} (\emph{nodal delay}).
	
	\begin{flushleft}
		\large \textcolor{Red3}{\textbf{Ritardo di elaborazione}}
	\end{flushleft}
	
	\noindent
	Il tempo richiesto per esaminare l’intestazione del pacchetto e per determinare dove dirigerlo fa parte del \textbf{ritardo di elaborazione} (\emph{processing delay}). Per dirigere si intende il tempo che impiega il \emph{router} a determinare la sua parte di uscita.
	
	\begin{flushleft}
		\large \textcolor{Red3}{\textbf{Ritardo di accodamento}}
	\end{flushleft}
	
	\noindent
	Una volta in coda, il pacchetto subisce un \textbf{ritardo di accodamento} (\emph{queuing delay}) mentre attende la trasmissione sul collegamento. La lunghezza di tale ritardo dipenderà dal numero di pacchetto precedentemente arrivati, accodati e in attesa di trasmissione sullo stesso collegamento. In altre parole, è il tempo speso nel \emph{buffer} prima che il pacchetto venga ritrasmesso.
	
	\begin{flushleft}
		\large \textcolor{Red3}{\textbf{Ritardo di trasmissione}}
	\end{flushleft}
	
	\noindent
	Data $L$ la lunghezza del pacchetto, in bit, e $R$ \emph{bps} la velocità di trasmissione del collegamento dal \emph{router} $A$ al \emph{router} $B$, il \textbf{ritardo di trasmissione} (\emph{transmission delay}) sarà $L\div R$. Questo è il tempo richiesto per trasmettere tutti i bit del pacchetto sul collegamento.\newline
	Più semplicemente, dipende dalla velocità di trasmissione e dalla dimensione del pacchetto ed è possibile sintetizzarlo con la formula:
	
	\begin{equation*}
		t_{\text{trasm}} = \dfrac{\text{dim\_pacchetto}}{\text{velocità\_trasmissione}}
	\end{equation*}
	
	\begin{flushleft}
	\large \textcolor{Red3}{\textbf{Ritardo di propagazione}}
	\end{flushleft}
	
	\noindent
	Una volta immesso sul collegamento, un bit deve propagarsi fino al \emph{router} B. Il tempo impiegato è il \textbf{ritardo di propagazione} (\emph{propagation delay}). In altre parole è il tempo impiegato per percorrere la distanza verso il \emph{router} successivo.
	
	\begin{flushleft}
		\large \textbf{Strumenti di misurazione}
	\end{flushleft}
	
	\noindent
	Esistono diversi \textbf{strumenti per misurare il ritardo}:
	
	\begin{itemize}
		\item \textbf{PING.} Dato un indirizzo di destinazione, il calcolatore manda una serie di messaggi e misura il tempo che intercorre tra l'invio e la ricezione della risposta, chiamato anche \emph{Rount Trip Time} (RTT).
		
		\item \textbf{TRACEROUTE.} Misura il \emph{Round Trip Time} tra la sorgente e \textbf{tutti} gli apparati di rete intermedi.
	\end{itemize}
	
	\newpage
	
	\subsection{Sintesi}
	
	\begin{itemize}[label=\ding{219}]
		\item \textbf{\emph{Internet Service Provider} (ISP).} Strumento utilizzato dai sistemi periferici per accedere ad Internet.
		
		\item \textbf{\emph{Provider}.} Insieme di commutatori di pacchetto e di collegamenti, solitamente è un'azienda che fornisce servizi.
		
		\item \textbf{\underline{Obbiettivi} ISP.} Fornire vari tipi di accesso alla rete ai dispositivi che si collegano (e.g. DSL, \emph{wireless}, ecc.).
		
		\item \textbf{\underline{Tipi} di ISP:}
			\begin{itemize}
				\item{\textbf{Livello 1.}} \emph{Internazionale} (Telecom, TIM, ...);
				\item{\textbf{Livello 2.}} \emph{Nazionale} (Fastweb);
				\item{\textbf{Livello 3.}} \emph{Locale} (solitamente per professionisti).
			\end{itemize}
		
		\item \textbf{Definizione TCP/IP.} Protocolli più famosi utilizzati dai sistemi periferici, i commutatori di pacchetto e altre parti di Internet. N.B. il protocollo IP specifica il formato dei pacchetti scambiati tra \emph{router} e sistemi periferici.
		
		\item \textbf{Definizione commutazione di circuito.}  Le risorse sono \underline{riservate} per l'intera comunicazione.
		
		\begin{enumerate}[label=\ding{43}]
			\item \textbf{\underline{Vantaggio} commutazione di circuito.} Velocità costante grazie ad un canale dedicato e quindi ritardo contenuto.
			
			\item \textbf{\underline{Svantaggio} commutazione di circuito.} Spreco di risorse in caso di silenzi durante la comunicazione.
			
			\item \textbf{\underline{Causa dei ritardi} nella commutazione di circuito.} I motivi possono essere tre:
			\begin{enumerate}[label=\Roman*]
				\item Instaurazione del circuito;
				\item Distanza tra sorgente e destinazione;
				\item Trasmissione vera e propria della comunicazione.
			\end{enumerate}
		\end{enumerate}
		
		\item \textbf{Definizione commutazione di pacchetto.} La sorgente divide i messaggi in parti più piccole chiamate \textbf{pacchetti}.
		
		\begin{enumerate}[label=\ding{43}]
			\item \textbf{\underline{Vantaggio} commutazione di pacchetto.} Ottimizzazione delle risorse poiché c'è una condivisione durante l'inattività.
			
			\item \textbf{\underline{Svantaggi} commutazione di circuito.} Eventuale perdita di pacchetti nel caso in cui un nodo intermedio abbia il \emph{buffer} saturo (generazione di \emph{buffer overflow}); ritardo causato da \emph{store and forward} poiché ogni pacchetto per essere inoltrato deve essere completamente trasmesso; all'aumentare dei nodi intermedi, il ritardo aumenta.
		\end{enumerate}
	
		\item \textbf{Ritardo di elaborazione (\emph{processing delay}).} Tempo impiegato dal \emph{router} per esaminare l'intestazione del pacchetto e determinare l'uscita.
		
		\item \textbf{Ritardo di accodamento (\emph{queuing delay}).} Tempo impiegato dal pacchetto all'interno della coda del buffer del \emph{router}.
		
		\item \textbf{Ritardo di trasmissione (\emph{transmission delay}).} Tempo che dipende dal rapporto tra la dimensione del pacchetto e la velocità di trasmissione.
		
		\item \textbf{Ritardo di propagazione (\emph{propagation delay}).} Tempo impiegato per percorrere la distanza verso il \emph{router} successivo.
		
		\item \textbf{Strumenti per la misurazione del ritardo.} I due strumenti sono ``PING'' e ``TRACEROUTE''. La differenza è che PING misura il RTT tra sorgente e destinazione, mentre il TRACEROUTE misura il RTT tra sorgente e \underline{ogni} nodo intermedio.
	\end{itemize}

	\newpage

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% Tecnica di load balancing, Throughput e collo di bottiglia %
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Tecnica di load balancing, Throughput e collo di bottiglia}
	
	\subsection{Tecnica di load balancing}
	
	Nel momento in cui il \textbf{mittente} (sorgente) calcola il \textbf{percorso migliore} per inviare i suoi dati al destinatario, può accadere che \textbf{trovi due o più strade identiche}. Con quest'ultimo termine si intende che i percorsi con il costo minimo, e quindi i più efficienti, siano due o più. In questo caso, viene applicata la tecnica di load balancing.
	
	La tecnica di \textcolor{Red3}{\textbf{\underline{load balancing}}} prevede di suddividere il carico dei pacchetti in tutti i percorsi migliori trovati. In questo modo, la comunicazione non avrà un unico percorso sovraccaricato, ma il carico sarà diviso tra più percorsi.
	
	\subsection{Throughput}
	
	Un’altra misura che influisce sulle prestazioni in una rete di calcolatori è il throughput \emph{end-to-end}. Esistono \textcolor{Red3}{\textbf{due tipi di throughput}}:
	
	\begin{itemize}
		\item \textcolor{Red3}{\textbf{Throughput \underline{istantaneo}}}, in ogni istante di tempo $p$, è la velocità (misurata in bit per secondo, \emph{bps}) alla quale il destinatario $B$ sta ricevendo il file.
		
		\item \textcolor{Red3}{\textbf{Throughput \underline{medio}}} è dato da una formula specifica. Se l'oggetto da inviare è formato da $F$ bit e il trasferimento richiede $T$ secondi affinché il destinatario $B$ riceva tutti gli $F$ bit, allora il throughput medio del trasferimento dell'oggetto da inviare è di
		\begin{equation*}
			\dfrac{F}{T} \: bit \: per \: secondo
		\end{equation*}
	\end{itemize}

	\subsection{Collo di bottiglia}

	\noindent
	Quindi, la connessione \emph{end-to-end} presenta criticità nel momento in cui più dispositivi dividono la strada tra sorgente e destinazione. Si parla, infatti, di \textcolor{Red3}{\textbf{\underline{collo di bottiglia}}} (\emph{bottleneck link}), nel momento in cui la velocità di trasferimento viene diminuita a causa di un canale più piccolo o a causa di un dispositivo con banda minore.
	
	\newpage
	
	\section{Architettura a livelli e incapsulamento}
	
	\subsection{Architettura a livelli}
	
	Un'\textcolor{Red3}{\textbf{architettura a livelli}} consente di manipolare una parte specifica e ben definita di un sistema articolato e complesso.\newline
	
	\noindent
	Questa struttura è data dal fatto che fin quando ciascun \textbf{livello} (\emph{layer}, o strato) fornisce lo stesso servizio allo strato superiore e utilizza gli stessi servizi dello stato inferiore, la parte rimanente del sistema rimane invariata al variare dell'implementazione a quel livello.\newline
	
	\noindent
	I \textbf{servizi} vengono offerti da un determinato livello a quello superiore, ovvero si tratta del \textbf{modello di servizio} (\emph{service model}) di un livello. Più in generale, \textbf{ogni livello fornisce il suo servizio} effettuando determinate azioni all'interno del livello stesso e utilizzando i servizi del livello immediatamente inferiore.\newline
	
	\noindent
	Nel caso di sistemi grandi e complessi, che vengono costantemente aggiornati, la capacità di cambiare l'implementazione di un servizio senza coinvolgere altre componenti del sistema costituisce un ulteriore importante vantaggio legato alla stratificazione. Quindi, i pro e i contro di questa architettura sono:
	
	\begin{itemize}
		\item \textcolor{Green4}{\textbf{\underline{Vantaggio}}}
		\begin{itemize}
			\item Il sistema è strutturato e dunque permette il trattamento dei componenti senza stravolgere l'intera architettura o struttura.
		\end{itemize}
		
		\item \textcolor{Red3}{\textbf{\underline{Svantaggi}}}
		\begin{itemize}
			\item Possibilità di duplicazione delle funzionalità tra due o più livelli, ovvero che un livello cloni le caratteristiche del livello inferiore;
			
			\item Possibilità che la funzionalità presente ad un livello possa richiedere informazioni presenti solo ad un altro livello.
		\end{itemize}
	\end{itemize}

	\noindent
	Ogni livello ha un \textbf{protocollo} e l’insieme dei protocolli vengono definiti \textbf{pila di protocolli} (\emph{protocol stack}). La pila di protocolli di Internet consiste di cinque livelli:
	
	\begin{enumerate}
		\item Fisico
		\item Collegamento
		\item Rete
		\item Trasporto
		\item Applicazione
	\end{enumerate}

	\noindent
	Un \textcolor{Red3}{\textbf{protocollo}} definisce il formato e l’ordine dei messaggi scambiati tra due o più entità in comunicazione, così come le azioni intraprese in fase di trasmissione e/o ricezione di un messaggio o di un altro evento.
	
	\newpage
	
	\subsection{Incapsulamento}
	
	L'\textcolor{Red3}{\textbf{incapsulamento}} (o imbustamento) è un modus operandi applicato nel momento in cui si deve inviare un messaggio.
	
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=\textwidth]{img/incapsulamento.pdf}
	\end{figure}

	La comunicazione avviene nel seguente modo:
	
	\begin{enumerate}
		\item Parte nel \textbf{\underline{livello di applicazione}} del host mittente il quale crea un \textbf{messaggio a livello di applicazione} (\emph{application-layer message}) concatenando informazioni aggiuntive, o meglio le informazioni di intestazione. Alla fine del processo di creazione, il messaggio viene passato al livello inferiore, quello di trasporto;
		
		\item A \textbf{\underline{livello di trasporto}} vengono aggiunte altre informazioni di intestazione. Le intestazioni di applicazione e trasporto formano il \textbf{segmento a livello di trasporto} (\emph{transport-layer segment}) che incapsula il messaggio a livello di applicazione. Infine, il livello di trasporto passa il messaggio al livello di rete;
		
		\item A \textbf{\underline{livello di rete}} vengono aggiunte informazioni come gli indirizzi dei sistemi periferici di sorgente e di destinazione. Facendo così viene creato un \textbf{datagramma a livello di rete} (\emph{network-layer datagram}). Infine, il messaggio viene passato al livello collegamento (\emph{link});
		
		\item A \textbf{\underline{livello di collegamento}} le informazioni aggiuntive creano un \textbf{frame a livello di collegamento} (\emph{link-layer frame});
		
		\item A \textbf{\underline{livello fisico}} vengono inviati i dati al router e qui termina l'incapsulamento.
	\end{enumerate}

	\noindent
	Per cui ad ogni livello, il pacchetto ha due tipi di campi: l’intestazione e \textbf{payload} (il carico utile trasportato). Il payload è tipicamente un pacchetto proveniente dal livello superiore.
	
	\section{Indirizzi IP}
	
	\subsection{Indirizzi IP}
	
	Un indirizzo IP consente di rendere \textbf{identificativo} e \textbf{univoco} un host all'interno della rete. Gli indirizzi IP vengono \textbf{rappresentati} con 32 bit e utilizzando una \textbf{notazione decimale puntata}. Prendendo in considerazione l’architettura di rete spiegata nel capitolo precedente, l’\underline{IP si posiziona al livello di rete}, nel quale viene aggiunto al messaggio da inviare.\newline
	
	\noindent
	La \textcolor{Red3}{\textbf{notazione decimale puntata}} è una rappresentazione degli indirizzi IP che facilita la lettura. Il modus operandi per ottenere tale notazione è il seguente:
	
	\begin{enumerate}
		\item Dividere i bit in 4 gruppi, ovvero 8 bit per ciascun gruppo;
		
		\item Traduzione di ogni gruppo da binario a decimale;
		
		\item Divisione di ogni gruppo da un punto.
	\end{enumerate}

	\noindent
	Negli indirizzi IP è importante dividere il prefisso dal suffisso poiché ogni parte ha un significato diverso:
	
	\begin{itemize}
		\item \textbf{\underline{Prefisso}}, identifica una rete all'interno di Internet;
		\item \textbf{\underline{Suffisso}}, identifica un host all'interno della rete.
	\end{itemize}
	
	\noindent
	Non esiste un numero specifico di indirizzi IP per il prefisso e per il suffisso. Questo perché dipendono entrambi dalla grandezza della rete; più è grande la rete e meno bit ha di prefisso.\newline
	
	\noindent
	Un \textbf{\emph{esempio}}: $157.27.12.63/16$, dove $157.27$ identifica il prefisso e $12.63$ il suffisso.
	
	\subsection{Maschera e blocco CIDR}
	
	Per identificare il numero di bit presenti nel prefisso, il calcolatore utilizza una sequenza di 32 bit in cui i bit del prefisso sono posti tutti a uno e i restanti a zero. Questo metodo si chiama maschera e un esempio di \textcolor{Red3}{\textbf{maschera}} 16 (notazione: /16):
	
	\begin{equation*}
		11111111111111110000000000000000
	\end{equation*}

	\noindent
	Che rappresenta l'indirizzo: $255.255.0.0$\newline
	
	\noindent
	Per cui si può affermare che la maschera \textbf{identifica} la grandezza della rete. Pensandoci, più è grande la maschera e più piccola è la rete visto che c’è una stretta relazione con il prefisso di un indirizzo IP.\newline
	
	\noindent
	Un \textcolor{Red3}{\textbf{blocco CIDR}} (\emph{Classless Inter-Domain Routing}) è un intervallo di indirizzi IP che sono disponibili nella propria rete.
	
	\newpage
	
	\subsection{\textcolor{Red3}{Esercizio di traduzione e numero host}}
	
	Dato il seguente indirizzo in notazione binaria:
	
	\begin{equation*}
		11100111 \hspace{1em} 11011011 \hspace{1em} 10001011 \hspace{1em} 01101111
	\end{equation*}

	\noindent
	Si rappresenta in notazione decimale puntata.\newline
	
	\noindent
	Per \textbf{prima cosa} si esegue la traduzione di ogni gruppo da binario a decimale:
	
	\begin{itemize}
		\item $11100111 \longrightarrow 2^{7} \cdot 1 + 2^{6} \cdot 1 + 2^{5} \cdot 1 + 2^{4} \cdot 0 + 2^{3} \cdot 0 + 2^{2} \cdot 1 + 2^{1} \cdot 1 + 2^{0} \cdot 1 = 231$
		
		\item $11011011 \longrightarrow 2^{7} \cdot 1 + 2^{6} \cdot 1 + 2^{5} \cdot 0 + 2^{4} \cdot 1 + 2^{3} \cdot 1 + 2^{2} \cdot 0 + 2^{1} \cdot 1 + 2^{0} \cdot 1 = 219$
		
		\item $10001011 \longrightarrow 2^{7} \cdot 1 + 2^{6} \cdot 0 + 2^{5} \cdot 0 + 2^{4} \cdot 0 + 2^{3} \cdot 1 + 2^{2} \cdot 0 + 2^{1} \cdot 1 + 2^{0} \cdot 1 = 139$
		
		\item $01101111 \longrightarrow 2^{7} \cdot 0 + 2^{6} \cdot 1 + 2^{5} \cdot 1 + 2^{4} \cdot 0 + 2^{3} \cdot 1 + 2^{2} \cdot 1 + 2^{1} \cdot 1 + 2^{0} \cdot 1 = 111$
	\end{itemize}

	\noindent
	E infine si riscrive la notazione in notazione decimale puntata:
	
	\begin{equation*}
		231.219.139.111
	\end{equation*}

	\noindent
	Adesso viene eseguita la conversione binaria della notazione decimale puntata del seguente indirizzo:
	
	\begin{equation*}
		221.34.255.82
	\end{equation*}

	\noindent
	Per \textbf{prima cosa} si esegue la traduzione di ogni gruppo. La traduzione non è banale, difatti si prenderà ciascun gruppo, si dividerà per due e nella colonna di destra verranno scritti i riporti. Infine, il numero binario sarà scritto dal numero di riporto del numero più basso, fino al numero più alto:
	
	\begin{center}
		\begin{tabular}{r|c}
			$221 \div 2$	&	1 \\
			$110 \div 2$	&	0 \\
			$55 \div 2$		&	1 \\
			$27 \div 2$		&	1 \\
			$13 \div 2$		&	1 \\
			$6 \div 2$		&	0 \\
			$3 \div 2$		&	1 \\
			$1 \div 2$		&	1			
		\end{tabular}
	\end{center}

	\noindent
	E così via. Unica accortezza da \textbf{ricordare} che se il numero di bit fosse meno di 8, si aggiungono zeri nella parte più significativa.\newline
	
	\noindent
	Dopo alcuni calcoli l’indirizzo IP in binario è:
	
	\begin{equation*}
		\binaryaddress{11011101}{00100010}{11111111}{01010010}
	\end{equation*}

	\noindent
	Una rete con un suffisso di /20, quanti host contiene? Dato un indirizzo IP da 32 bit, se il suffisso ha 20 bit, allora: $2^{32} \div 2^{20} = 2^{12}$. Una rete con un suffisso di 20 bit, avrà un prefisso di 12 bit, ovvero $2^{12} \longrightarrow 4096$ indirizzi.
	
	\newpage
	
	\section{Indirizzi IP privati}
	
	\subsection{Indirizzi IP privati}
	
	Gli indirizzi IP riservati sono indirizzi IP che non possono essere assegnati a nessun host. In particolare, sono:
	
	\begin{itemize}
		\item \textbf{Indirizzo di rete}: tutti i bit del suffisso sono posti a zero;
		\item \textbf{Indirizzo di Direct Broadcast}: tutti i bit del suffisso sono posti a uno;
		\item \textbf{Indirizzo con tutti i bit a zero};
		\item \textbf{Indirizzo con tutti i bit a uno};
	\end{itemize}

	\subsection{\textcolor{Red3}{Esercizio subnetting, creazione sottoreti partendo da un blocco di indirizzi}}
	
	La tecnica di \textcolor{Red3}{\textbf{\emph{subnetting}}} consiste nel suddividere una rete in più rete, chiamate sottoreti. L'esercizio fornisce un indirizzo IP:
	
	\begin{equation*}
		180.190.0.0/16
	\end{equation*}

	\noindent
	E l'obbiettivo è quello di creare due sottoreti di grandezza identica.\newline
	
	\noindent
	Per \textbf{prima cosa} si deve effettuare la conversione da notazione decimale puntata a notazione binaria:
	
	\begin{equation*}
		\binaryaddress{10110100}{10111110}{00000000}{00000000}
	\end{equation*}

	\noindent
	A questo punto è possibile creare due sottoreti come richiesto dall’esercizio.\newline
	
	\noindent
	Per farlo si identifica il primo bit utile nell'indirizzo binario. Esso è possibile trovarlo escludendo il prefisso ($/16$). Quindi, si conta dal bit più significativo $16$ bit, escluso sé stesso, arrivando al bit numero 17, ovvero il più significativo del terzo gruppo:
	
	\begin{equation*}
		\binaryaddress{10110100}{10111110}{\textcolor{Red3}{\boldsymbol{x}}0000000}{00000000}
	\end{equation*}

	\noindent
	Al posto della $\textcolor{Red3}{\boldsymbol{x}}$ verrà sostituito lo zero per creare la prima rete e l’uno per creare la seconda rete. Gli indirizzi saranno:
	
	\begin{equation*}
		\begin{array}{ll}
			\text{Ind. bin. della \textbf{prima rete}:} 	& \binaryaddress{10110100}{10111110}{\textcolor{Red3}{\boldsymbol{0}}0000000}{00000000} \\
			\text{Ind. bin. della \textbf{seconda rete}:} 	& \binaryaddress{10110100}{10111110}{\textcolor{Red3}{\boldsymbol{1}}0000000}{00000000}
		\end{array}
	\end{equation*}

	\noindent
	Il \textbf{prefisso} delle sottoreti sarà aumentato di un solo bit, per cui saranno $/17$.\newline
	
	\noindent
	La \textbf{traduzione in decimale} sarà:
	
	\begin{itemize}
		\item \textbf{Prima rete:} $180.190.0.0/17$
		\item \textbf{Seconda rete:} $180.190.128.0/17$
	\end{itemize}

	\noindent
	La \textbf{maschera} delle sottoreti sarà formata da $17$ bit posti a $1$ partendo dal più significativo:
	
	\begin{equation*}
		\binaryaddress{11111111}{11111111}{10000000}{00000000}
	\end{equation*}

	\noindent
	E la \textbf{traduzione della maschera} in notazione decimale puntata sarà:
	
	\begin{equation*}
		255.255.128.0
	\end{equation*}

	\noindent
	Infine, la \textbf{dimensione dei blocchi} di rete:
	
	\begin{equation*}
		\begin{array}{llll}
			\textbf{Pre-subnetting}:	&	2^{32} \div 2^{16} = 2^{16}	&	\longrightarrow	&	65'536 \text{ indirizzi} \\
			&&& \\
			\textbf{Post-subnetting}: 	&	2^{32} \div 2^{17} = 2^{15}	&	\longrightarrow	&	32'768 \text{ indirizzi}
		\end{array}
	\end{equation*}

	\newpage
	
	\section{Socket e protocolli a livello di trasporto: TCP e UDP}
	
	\subsection{Socket}
	
	I sistemi periferici collegati a Internet forniscono un'\textcolor{Red3}{\textbf{interfaccia socket}} (\emph{socket interface}), che specifica come un programma eseguito su un sistema periferico possa chiedere a Internet di recapitare dati a un programma eseguito su un altro sistema periferico.\newline
	
	\noindent
	\emph{In altre parole}, l’interfaccia socket è un insieme di regole che il programma mittente deve seguire in modo che i dati siano recapitati al programma di destinazione.\newline
	
	\noindent
	È importante anche sapere l’esistenza delle \textbf{API} (\emph{Application Programmin Interface}) tra l’applicazione e la rete, poiché l’interfaccia socket non è altro che un’interfaccia di programmazione con cui le applicazioni di rete vengono costruite.\newline
	
	\noindent
	Infine, esistono due tipi di processi:
	
	\begin{itemize}
		\item Il \textbf{client}, ovvero colui che avvia la comunicazione e ha un \underline{IP dinamico};
		\item Il \textbf{server}, ovvero colui che attende di essere contattato per iniziare la sessione e ha un \underline{IP statico}.
	\end{itemize}

	\newpage
	
	\subsection{Protocolli nel livello di trasporto}
	
	Dopo il livello applicativo, si trova il livello di trasporto. Esso può utilizzare due possibili \textbf{protocolli} nelle reti TCP/IP: \textcolor{Red3}{\textbf{TCP}} e \textcolor{Red3}{\textbf{UDP}}.
	
	\subsubsection{Protocollo TCP}\label{protocollo TCP}
	
	Il protocollo TCP prevede la fornitura di un servizio \textbf{orientato alla connessione} (\emph{Connection oriented communication}) e il \textbf{trasporto affidabile dei dati}.\newline
	
	\noindent
	Le \textbf{caratteristiche} di questo protocollo sono:
	
	\begin{itemize}
		\item \textcolor{Green4}{\textbf{Servizio orientato alla connessione}}. Questa caratteristica deriva dal fatto che vengono scambiate delle informazioni di controllo prima che i messaggi veri e propri vengano processati dal livello applicativo. Questo \underline{scambio di messaggi} prende il nome di \textbf{handshaking}.\newline
		Successivamente, \emph{se tutto è andato a buon fine}, si instaura una \textbf{connessione TCP} tra le socket dei due processi. La connessione viene chiamata \textbf{\emph{full-duplex}} ovvero i due processi possono scambiarsi i messaggi contemporaneamente sulla connessione.
		Infine, per \underline{terminare la connessione}, il mittente e il destinatario si \textbf{scambiano} alcuni \textbf{messaggi}.
		
		\item \textcolor{Green4}{\textbf{Servizio di trasferimento affidabile}}. Il protocollo è affidabile poiché i vari controlli effettuati permettono di:
		\begin{itemize}
			\item Non perdere dati;
			\item Inviarli nel giusto ordine;
			\item Evitare duplicazioni.
		\end{itemize}
	\end{itemize}
	
	\noindent
	Inoltre, questo protocollo implementa un meccanismo di \textbf{controllo della congestione}. Nel caso in cui si manifestasse, eseguirebbe una \dquotes{strozzatura} del processo d’invio.\newline
	
	\noindent
	Infine, il protocollo negli ultimi anni implementa anche il \textbf{\emph{secure sockets layer}} (\textbf{SSL}). Ovvero un servizio aggiuntivo che consente la cifratura dei messaggi. Attenzione che questo servizio deve essere attivo sia lato client che lato server, altrimenti si rischia che una delle due parti non possa decifrare il messaggio ricevuto.
	
	\newpage
		
	\subsubsection{Protocollo UDP}\label{protocollo UDP}
	
	Al contrario del protocollo TCP, UDP è un protocollo di trasporto \textbf{leggero}, \textbf{rapido} e \textbf{minimalista}. Esso \emph{\textbf{non}} necessita di connessione, per cui \underline{non esegue} \underline{alcun handshaking} e di conseguenza \textbf{non} fornisce neanche un \textbf{trasferimento dati affidabile}.\newline
	
	\noindent
	Per cui, quando processo invia un messaggio tramite un socket, UDP \textbf{non garantisce la consegna del messaggio}. Inoltre, i messaggi potrebbero giungere a destinazione non in ordine.\newline
	
	\noindent
	La \textbf{rapidità del protocollo} è dovuta anche al fatto che i pacchetti vengono inviati direttamente \textbf{senza} utilizzare un sistema di \textbf{controllo della congestione}. Tuttavia, il reale throughput end-to-end potrà essere inferiore a causa della banda limitata dei collegamenti coinvolti o a causa della congestione. Si ricorda che con il termine throughput ci si riferisce al tasso con quale il processo mittente può inviare i bit al processo ricevente.
	
	\begin{itemize}
		\item \textcolor{Green4}{\textbf{\underline{Vantaggi}}}
		\begin{itemize}
			\item \textbf{\underline{Leggero}} poiché non ha bisogno di controllare che la connessione sia instaurata, ovvero il fenomeno di \emph{handshaking} viene eliminato;
			
			\item \textbf{\underline{Rapido}} poiché non esiste nessun sistema di controllo della congestione, per cui i pacchetti vengono mandati uno dopo l'altro. Talvolta il throughput potrebbe essere minore a causa di eventuali colli di bottiglia;
			
			\item \textbf{\underline{Minimalista}} poiché non implementa tecniche particolari come detto in precedenza.
		\end{itemize}
		
		\item \textcolor{Red3}{\textbf{\underline{Svantaggi}}}
		\begin{itemize}
			\item \textbf{\underline{Nessuna affidabilità}} a causa della mancanza del fenomeno di \emph{handshaking}. Quindi, \textbf{nessuna garanzia di consegna} del messaggio;
			
			\item \textbf{\underline{Alta probabilità di congestione}} dovuta alla mancanza di controllo di essa. Quindi, il buffer potrebbe riempirsi rapidamente;
			
			\item \textbf{\underline{Messaggi non in ordine}}.
		\end{itemize}
	\end{itemize}

	\newpage
	
	\subsection{\textcolor{Red3}{Esercizio sull'indirizzamento}}
	
	Dato il seguente IP:
	
	\begin{equation*}
		140.120.84.20/20
	\end{equation*}
	
	\noindent
	Determinare l’indirizzo di rete.\newline
	
	\noindent
	Il \textbf{primo passo} è la traduzione dell’IP da notazione decimale puntata a notazione binaria:
	
	\begin{equation*}
		\begin{array}{lll}
			140_{10}	& \longrightarrow & 10001100 \\
			&& \\
			120_{10}	& \longrightarrow & 01111000 \\
			&& \\
			84_{10}		& \longrightarrow & 01010100 \\
			&& \\
			20_{10}		& \longrightarrow & 00010100
		\end{array}
	\end{equation*}
	
	\noindent
	Scrivendo l’indirizzo esteso:
	
	\begin{equation*}
		\binaryaddress{10001100}{01111000}{01010100}{00010100}
	\end{equation*}

	\noindent
	Il \textbf{secondo passo} è l’azzeramento del suffisso (bits in rosso) dato che l’indirizzo di rete ha il prefisso \emph{non} nullo e il suffisso con tutti i bit a zero. Il prefisso viene dato dall’ esercizio, ovvero $/20$:
	
	\begin{equation*}
		\binaryaddress{10001100}{01111000}{0101\textcolor{Red3}{\boldsymbol{0000}}}{\textcolor{Red3}{\boldsymbol{00000000}}}
	\end{equation*}

	\noindent
	Il \textbf{terzo} e ultimo \textbf{passo} è la conversione in decimale e scrivere l’indirizzo di rete in notazione decimale puntata:
	
	\begin{equation*}
		\begin{array}{lll}
			10001100_{2}	& \longrightarrow & 140_{10} \\
			&& \\
			01111000_{2}	& \longrightarrow & 120_{10} \\
			&& \\
			01010000_{2}	& \longrightarrow & 80_{10} \\
			&& \\
			00000000_{2}	& \longrightarrow & 0_{10}
		\end{array}
	\end{equation*}

	\noindent
	E l'indirizzo di rete sarà:
	
	\begin{equation*}
		140.120.80.0/20
	\end{equation*}

	\newpage
	
	\subsection{\textcolor{Red3}{Esercizio subnetting - Avanzato}}
	
	Date 3 reti LAN, viene assegnato il blocco di rete 165.5.1.0/24. Creare 3 sottoreti per ogni rete LAN in modo da avere lo stesso numero di host.\newline
	
	Il \textbf{primo passo} è la classica traduzione in binaria. Si deve tradurre l’indirizzo da notazione decimale puntata a binario:
	
	\begin{equation*}
		\begin{array}{lll}
			165_{10}	& \longrightarrow & 10100101_{2} \\
			5_{10}		& \longrightarrow & 00000101_{2} \\
			1_{10}		& \longrightarrow & 00000001_{2} \\
			0_{10}		& \longrightarrow & 00000000_{2}
		\end{array}
	\end{equation*}

	\noindent
	Il \textbf{secondo passo} è quello di creare delle sottoreti. Per farlo si deve prendere in considerazione il suffisso. Prima di tutto, si scrive l’indirizzo in notazione binaria:
	
	\begin{equation*}
		\binaryaddress{10100101}{00000101}{00000001}{00000000}
	\end{equation*}

	\noindent
	La creazione di 3 sottoreti prevede almeno due bit. Difatti, se venisse scelto un bit, si potrebbe creare al massimo 2 sottoreti. Per cui, dall’indirizzo in notazione binaria, si riservano (x in rosso) due bit nel suffisso per creare le sottoreti:
	
	\begin{equation*}
		\binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{xx}}000000}
	\end{equation*}

	\noindent
	Riservando questi due bit, adesso si sono create quattro sottoreti:
	
	\begin{equation*}
		\begin{array}{ll}
			\textbf{LAN1.} & \binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{00}}000000} \\
			\textbf{LAN2.} & \binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{01}}000000} \\
			\textbf{LAN3.} & \binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{10}}000000} \\
			\textbf{LAN4.} & \binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{11}}000000} \\
		\end{array}
	\end{equation*}

	\noindent
	La prima sottorete è assegnata alla LAN1, la seconda alla LAN2, la terza alla LAN3 e la quarta è considerata libera. Essa potrà essere utilizzata in futuro.\newline
	
	\noindent
	Il \textbf{terzo passo} è calcolare il nuovo prefisso delle sottoreti. Ogni sottorete è formata dal prefisso della rete originaria ($/24$), più due bit che sono serviti per creare le 3 reti. Quindi, il nuovo prefisso delle 3 reti è diventato $/26$.\newline
	
	\noindent
	Infine, il \textbf{quarto passo} è la scrittura in notazione decimale puntata delle tre reti e il calcolo degli indirizzi disponibili.\newline
	
	\noindent
	La conversione è semplice e si omettono i passaggi e le spiegazioni:
	
	\begin{equation*}
		\begin{array}{ll}
			\textbf{LAN1.} & 165.5.1.0/26 \\
			\textbf{LAN2.} & 165.5.1.64/26 \\
			\textbf{LAN3.} & 165.5.1.128/26 \\
			\textbf{LAN4.} & 165.5.1.192/26 \\
		\end{array}
	\end{equation*}

	\noindent
	E la rete è passata da avere ($2^{32} \div 2^{24} = 2^{8}$) 256 indirizzi disponibili a ($2^{32} \div 2^{26} = 2^{6}$) 64 indirizzi.
	
	\newpage
	
	\subsubsection{\textcolor{Red3}{Domanda bonus}}
	
	Se la LAN1 avesse dovuto avere il doppio degli indirizzi rispetto alla LAN2 e alla LAN3, l'esercizio come si sarebbe svolto?\newline
	
	\noindent
	In questo caso specifico, partendo dal \textbf{passo numero due}, ovvero alla creazione delle sottoreti, si sarebbe proceduti in maniera diversa.\newline
	
	\noindent
	Invece di prendere due bit, si prende un solo bit che ci permette di creare due sottoreti: nella prima sottorete si assegna la LAN1 e nella seconda sottorete si assegnano LAN2 e LAN3.
	\begin{equation*}
		\binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{x}}0000000}
	\end{equation*}
	
	\noindent
	Creando le due sottoreti:
	\begin{gather*}
		\binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{0}}0000000} \\
		\binaryaddress{10100101}{00000101}{00000001}{\textcolor{Red3}{\boldsymbol{1}}0000000}
	\end{gather*}
	
	\noindent
	Il \textbf{terzo passo} è quello di creare le due sottoreti all’interno del secondo indirizzo. Due sottoreti necessitano di due bit, per cui la divisione sarà:
	\begin{equation*}
		\begin{array}{ll}
			\textbf{LAN2.} & \binaryaddress{10100101}{00000101}{00000001}{1\textcolor{Red3}{\boldsymbol{0}}000000} \\
			\textbf{LAN3.} & \binaryaddress{10100101}{00000101}{00000001}{1\textcolor{Red3}{\boldsymbol{1}}000000}
		\end{array}
	\end{equation*}

	\noindent
	Infine, il \textbf{quarto passo} è quello di calcolare la maschera delle reti, riscrivere gli indirizzi in notazione decimale puntata e calcolare il numero di indirizzi possibili.\newline
	
	\noindent
	La maschera per la LAN1 è aumentata di 1 dalla rete di partenza, per cui $/25$. Mentre per la LAN2 e LAN3 è aumentata di 2 bit, ovvero $/26$.\newline
	
	\noindent
	La scrittura in notazione decimale puntata sarà:
	\begin{equation*}
		\begin{array}{ll}
			\textbf{LAN1.} & 165.5.1.0/25 \\
			\textbf{LAN2.} & 165.1.128/26 \\
			\textbf{LAN3.} & 165.1.192/26
		\end{array}
	\end{equation*}

	\noindent
	E il numero di indirizzi della LAN1 saranno ($2^{32} \div 2^{25} = 2^{7}$) 128, mentre quelli della LAN2 e della LAN3 rimarranno a 64 indirizzi.
	
	\newpage
	
	\section{Protocollo HTTP}
	
	\subsection{Protocollo HTTP}
	
	\textcolor{Red3}{\textbf{HTTP}} (\emph{Hypertext Transfer Protocol}), protocollo a livello di applicazione del Web, costituisce il cuore del Web. Questo \textbf{protocollo} è implementato nei programmi in esecuzione su sistemi periferici diversi che comunicano tra loro scambiandosi messaggi HTTP.\newline
	
	\noindent
	Una \textbf{pagina web} (\emph{web page}), detta anche documento, è costituita da oggetti. Un \textbf{oggetto} è semplicemente un file indirizzabile tramite un URL. La maggioranza delle pagine web consiste di un \textbf{file HTML principale} e diversi oggetti referenziati da esso.\newline
	
	\noindent
	Un \textbf{browser web} implementa il lato \emph{client} di HTTP, ovvero l’utente stesso. Mentre il \textbf{web server} implementa il lato server di HTTP, ospita oggetti web, indirizzabili tramite URL.\newline
	
	\noindent
	HTTP utilizza il protocollo \textbf{TCP come protocollo di trasporto}. Il client HTTP per prima cosa inizia una connessione TCP con il server. Una volta stabilita, i processi client e server accedono a TCP attraverso le proprie socket.\newline
	
	\noindent
	Dato che i server HTTP non mantengono informazioni sui client, HTTP è classificato come \textbf{protocollo senza memoria di stato} (\emph{stateless protocol}). Un \textbf{web server} è \textbf{sempre attivo}, ha un indirizzo IP fisso e risponde potenzialmente alle richieste provenienti da milioni di diversi browser.
	
	\subsection{HTTP con connessioni (non) persistenti}
	
	Sia i client che i server possono avere due diverse configurazioni: le connessioni persistenti e le connessioni non persistenti. Prima di iniziare la spiegazione, si introduce il concetto di \textcolor{Red3}{\textbf{round-trip time}} (\textbf{RTT}), che rappresenta il \textbf{tempo impiegato da un pacchetto per viaggiare dal client al server e poi tornare al client}. Esso include i \textbf{ritardi di propagazione}, di \textbf{accodamento} nei \textbf{router} e nei \textbf{commutatori intermedi} nonché di elaborazione del pacchetto.
	
	\newpage
	
	\subsubsection{Connessioni non persistenti}
	
	Per spiegare le connessioni non persistenti, si faccia riferimento ad un esempio in cui c’è il trasferimento di una pagina web dal server al client. Si supponga che la pagina consista di un file HTML principale e di 10 immagini, e tutti gli oggetti risiedano sullo stesso server.
	
	\begin{enumerate}
		\item Il processo client HTTP inizializza una connessione di tipo TCP con il server sulla porta 80, ovvero la porta di default per HTTP.
		
		\item Il client HTTP, tramite la socket, invia al server un messaggio di richiesta del file principale.
		
		\item Il processo server HTTP riceve il messaggio di richiesta attraverso la socket, recupera l’oggetto richiesto dalla propria memoria, lo incapsula in un messaggio di risposta che viene inviato al client attraverso la socket.
		
		\item Il processo server HTTP comunica a TCP di concludere la connessione. Tuttavia, il protocollo TCP garantisce la consegna del messaggio, per cui non termina la connessione finché il client non ha ricevuto l’intero messaggio.
		
		\item Il client HTTP riceve il messaggio di risposta. La connessione TCP termina a questo punto e il messaggio ricevuto indica che l’oggetto incapsulato è un file HTML. Il client estrae il file del messaggio di risposta, esamina il file HTML e trova i riferimenti ai 10 oggetti.
		
		\item Infine, vengono ripetuti tutti i primi quattro passi per ciascuno degli oggetti referenziati.
	\end{enumerate}

	\noindent
	Si conclude che l’utilizzo di connessione non persistenti, consente di chiudere ogni connessione aperta dopo l’invio dell’oggetto da parte del server e dopo aver ricevuto una conferma dal client.\newline
	
	\noindent
	Nell’esempio vengono create 11 connessioni TCP, una per ogni oggetto richiesto.\newline
	
	\noindent
	Come si può notare, queste connessioni presentano alcuni \textbf{limiti}:
	
	\begin{enumerate}
		\item Per ogni oggetto richiesto occorre stabilire e mantenere una nuova connessione.
		
		\item Per ogni connessione si deve allocare buffer e mantenere variabili TCP sia nel client che nel server.
		
		\item Ciascun oggetto subisce un ritardo di consegna di due RTT: uno per stabilire la connessione TCP e uno per richiedere e ricevere un oggetto.
	\end{enumerate}

	\noindent
	Questi limiti richiedono un grande onere sul web server che deve aprire nuove connessioni ogni qualvolta ci deve essere uno scambio di dati. Il grande onere riguarda soprattutto il momento in cui il server riceve centinaia di richieste da parte dei client.
	
	\newpage
	
	\subsubsection{Connessioni persistenti}
	
	La particolarità delle connessioni persistenti è la possibilità da parte del server di lasciare aperta la connessione TCP dopo l’invio di una risposta. Così facendo, le richieste/risposte future da parte degli stessi client e server potranno essere trasmesse sulla stessa connessione.\newline
	
	\noindent
	Difatti, il server può inviare un’intera pagina web \textbf{sfruttando} solamente \textbf{una connessione} TCP permanente, oppure inviare più pagine web allo stesso client.\newline
	
	\noindent
	Le \textbf{richieste} possono essere effettuate \textbf{una dopo l’altra senza attendere} le risposte delle eventuali richieste pendenti (\emph{pipelining}).\newline
	
	\noindent
	In generale, il server HTTP \textbf{chiude la connessione} quando essa rimane inattiva per un lasso di tempo arbitrario.
	
	\newpage
	
	\subsection{Formato dei messaggi HTTP}
	
	Esistono due tipi di formati di questo protocollo: il messaggio di richiesta HTTP e messaggio di risposta HTTP.
	
	\subsubsection{Messaggio di richiesta HTTP}
	
	I messaggi di richiesta possono avere un numero indefinito di righe, anche una sola.\newline
	
	\noindent
	Ogni riga alla fine ha un \textbf{carattere di ritorno a capo} (\emph{carriage return}) e un \textbf{carattere di nuova linea} (\emph{line feed}).\newline
	
	\noindent
	L’ultima riga è seguita da una coppia di caratteri di ritorno a capo e nuova linea aggiuntivi.\newline
	
	\noindent
	In generale, la \textbf{prima riga} è la \textbf{riga di richiesta} (\emph{request line}) e quelle successive si chiamano \textbf{righe di intestazione} (\emph{header lines}).\newline
	
	\noindent
	La \textbf{riga di richiesta} è formata da tre campi:
	
	\begin{itemize}
		\item Campo \textbf{metodo} (GET, POST, HEAD, PUT, DELETE)
		\item Campo \textbf{URL}
		\item Campo \textbf{versione HTTP}
	\end{itemize}
	
	\noindent
	Le \textbf{righe di intestazione} possono essere di molti tipi. La riga \textbf{Host} specifica l’host su cui risiede l’oggetto, la riga \textbf{Connection} indica se il server deve effettuare una connessione di tipo persistente o non persistente, la riga \textbf{User-agent} specifica il tipo di browser che sta effettuando la richiesta al server e, infine, la riga \textbf{Accept-language} indica se l’utente preferisce ricevere una versione dell’oggetto nella lingua specificata; in caso di mancanza, il server provvederà a fornire la versione di default.
	
	\newpage
	
	\subsubsection{Messaggio di risposta HTTP}
	
	Nei messaggi di risposta ci sono tre sezioni importanti: una \textbf{riga di stato iniziale}, le \textbf{righe di intestazione} e il \textbf{corpo}.\newline
	
	\noindent
	La \textbf{riga di stato iniziale} presenta tre campi:
	
	\begin{itemize}
		\item \textbf{Versione del protocollo}
		\item \textbf{Codice di stato}
		\item \textbf{Messaggio di stato} (approfondimento alla fine di questo paragrafo)
	\end{itemize}

	\noindent
	Le \textbf{righe di intestazione} possono essere di tipo \textbf{Connection} per comunicare al client la gestione della connessione, per esempio “Connection: close” per indicare l’intenzione di chiudere la connessione TCP dopo l’invio del messaggio; di tipo \textbf{Date} per indicare l’ora e la data di creazione e invio, da parte del server, della risposta HTTP; di tipo \textbf{Server} per indicare che il messaggio è stato generato da un determinato tipo di web server, simile alla riga “User-agent” nel messaggio di richiesta; di tipo \textbf{Last-Modified} per indicare l’istante e la data in cui l’oggetto è stato creato o modificato per l’ultima volta; di tipo \textbf{Content-Length} per indicare il numero di byte dell’oggetto inviato; di tipo \textbf{Content-Type} per indicare il tipo di oggetto specificato nel corpo.\newline
	
	\noindent
	Le \textbf{righe di corpo} sono il fulcro del messaggio. Esse contengono l’oggetto richiesto.\newline
	
	\noindent
	Nella \textbf{riga di stato iniziale}, i due campi \textbf{codice} e \textbf{messaggio di stato} indicano operazioni importanti. Qui di seguito si elencano i codici con i relativi messaggi, sono riportati solo i più importanti:
	
	\begin{itemize}
		\item 200 OK: la richiesta ha avuto successo e in risposta si invia l'informazione.
		
		\item 301 Moved Permanently: l’oggetto richiesto è stato trasferito in modo permanente; il nuovo URL viene specificato nell’intestazione, campo Location, del messaggio di risposta.
		
		\item 400 Bad Request: codice di errore generico che indica che la richiesta non è stata compresa dal server.
		
		\item 404 Not Found: il documento richiesto non esiste sul server.
		
		\item 505 HTTP Version Not Supported: il server non dispone della versione di protocollo HTTP richiesta.
	\end{itemize}

	\newpage
	
	\subsection{Cookie}
	
	I \textcolor{Red3}{\textbf{\emph{cookie}}} è un meccanismo utilizzato dal server per sapere se ha interagito precedentemente con un determinato client.\newline
	
	\noindent
	La \textbf{prima volta} che il \emph{client} interagisce con un \emph{server}, inviando una richiesta GET, il server crea un identificativo (codice) associato all'utente (e.g. 1234).\newline
	
	\noindent
	Il server \textbf{risponde} con una richiesta REPLY HTTP, impostando nell'intestazione il valore \emph{\textbf{set-cookie}} al valore impostato al passaggio prima. Alla ricezione della risposta, il \emph{client} memorizza l'indirizzo della pagina usato per fare la prima richiesta GET e il codice fornito dal server (\emph{set-cookie}).\newline
	
	\noindent
	\textbf{Dopo una serie di interazioni}, quando il \emph{client} effettuerà di nuovo una richiesta GET al server specifico, esso dovrà indicare come codice \emph{cookie}, il codice salvato la prima volta. Invece, il server controllerà la storia associata all'utente con il codice fornito e restituisce una risposta specifica all'utente.
	
	\subsection{Cache di rete}
	
	La \textcolor{Red3}{\textbf{cache di rete}} intercetta i messaggi e memorizza le risposte. I vantaggi riguardano principalmente la velocità. Il suo funzionamento è il seguente:
	
	\begin{enumerate}
		\item Invio della richiesta di un determinato dato da parte del \emph{client};
		
		\item \textbf{Cache di rete} intercetta il messaggio e controlla se ha il dato richiesto:
		\begin{itemize}
			\item Se il \textbf{dato è presente}:
			\begin{enumerate}
				\item La cache di rete invia una richiesta di tipo \textcolor{Red3}{\textbf{GET condizionale}} per verificare che il contenuto del dato richiesto non sia stato modificato nel server (campo nell'intestazione: \emph{if-modified-since});
				
				\item Il server risponde inviando un messaggio con scritto nell'intestazione \emph{not modified};
				
				\item Cache di rete invia direttamente il dato al client diminuendo il tempo d'attesa del mittente (lo scambio di messaggi piccoli tra cache di rete e server è rapido!).
			\end{enumerate}
		
			\item Se il \textbf{dato \underline{non} è presente}:
			\begin{enumerate}
				\item La cache di rete invia una richiesta di tipo \textcolor{Red3}{\textbf{GET condizionale}} per verificare che il contenuto del dato richiesto non sia stato modificato nel server (campo nell'intestazione: \emph{if-modified-since});
				
				\item Il server di destinazione risponde inviando i dati richiesti (operazione lenta);
				
				\item La cache di rete intercetta la risposta salvando una copia dei dati al suo interno. La risposta non viene bloccata, quindi arriva anche al client,
			\end{enumerate}
		\end{itemize}
	\end{enumerate}

	\newpage
	
	\section{DNS}
	
	\subsection{DNS}
	
	Gli host Internet possono essere identificati in vari modi. I \textbf{nomi degli host} (\emph{hostname}), per esempio \textsf{www.facebook.com} o \textsf{www.google.com}, risultano abbastanza appropriati per l’uomo, ma forniscono ben poca informazione sulla loro collocazione all’interno di Internet. Per cui, i nomi vengono utilizzati dagli utenti finali, mentre i calcolatori utilizzando gli \textbf{indirizzi IP} degli host.\newline
	
	\noindent
	Gli utenti finali inseriscono i nomi degli host e il calcolatore riesce a ottenere l’indirizzo IP grazie ad un servizio in grado di tradurre i nomi in indirizzi IP. Il suo nome è \textcolor{Red3}{\textbf{Domain Name System}} (DNS).\newline
	
	\noindent
	Il \textbf{DNS} è un \textbf{database} distribuito implementato in una \textbf{gerarchia} di \textbf{DNS server} e un protocollo a livello di applicazione che consente agli \textbf{host} di \textbf{interrogare} il \textbf{database}. Generalmente i DNS server sono macchine UNIX che eseguono un software chiamato BIND (\emph{Berkeley Internet name domain}). Il protocollo DNS utilizza \textbf{UDP} e la \textbf{porta 53}.\newline
	
	\noindent
	Nel dettaglio quello che succede nel momento in cui un utente digita un host name:
	
	\begin{enumerate}
		\item La macchina utente (\emph{client}) esegue l’applicazione DNS;

		\item Il browser estrae il nome del host dall’URL inserito e lo passa all’applicazione DNS;

		\item L’applicazione DNS esegue una interrogazione (\emph{query}), sul database di una DNS server, contenente l’hostname;

		\item L’applicazione DNS prima o poi riceve una risposta che include l’indirizzo IP corrispondente al host dell’hostname fornito;

		\item Una volta ricevuto l’indirizzo IP dal DNS, il browser può dare inizio a una connessione di tipo TCP verso il processo server HTTP collegato alla porta 80 di quell’indirizzo IP.
	\end{enumerate}

	\newpage
	
	\subsection{Approfondimento sul database distribuito e gerarchico}
	
	Il DNS utilizza un grande numero di server, organizzati in maniera gerarchica e distribuiti nel mondo. Nessun DNS server ha le corrispondenze per tutti gli host in Internet, che sono invece distribuite tra tutti i DNS server.\newline
	
	\noindent
	Esistono \textbf{tre classi} di DNS server:
	
	\begin{itemize}
		\item \textbf{Root server}. In Internet esistono 400 root server circa, dislocati in tutto il mondo. Essi sono gestiti da 13 diverse organizzazioni.\newline
		I root server forniscono gli indirizzi IP dei server TLD.
		
		\item \textbf{Top-level domain (TLD) server}. Questi server si occupano dei domini di primo livello quali \emph{com}, \emph{org}, \emph{net}, \emph{edu} e \emph{gov}, e di tutti i domini di primo livello relativi ai vari paesi, come \emph{uk}, \emph{fr}, \emph{ca} e \emph{jp}. Per esempio, l’azienda “Verisign Global Registry Services” gestisce i TLD server per il dominio com.\newline
		I server TLD forniscono gli indirizzi IP dei server autoritativi.
		
		\item \textbf{Server autoritativi}.	Ogni organizzazione dotata di host pubblicamente accessibili tramite Internet (quali web server e e-mail server) deve fornire record DNS pubblicamente accessibili che associno i nomi di tali host a indirizzi IP. Il DNS server autoritativo dell’organizzazione ospita questi record.\newline
		Un’organizzazione può scegliere di implementare il proprio server autoritativo oppure di pagare un fornitore di servizi per ospitare questi record su un suo server.
	\end{itemize}

	\noindent
	Un \textbf{esempio} riepilogativo può essere del tipo: si supponga che un client DNS voglia determinare l’indirizzo IP relativo all’hostname \textsf{www.amazon.com}.\newline
	Per fare ciò, il client dapprima contatta uno dei root server che gli restituisce uno o più indirizzi IP relativi al server TLD per il dominio \emph{com} (dominio gestito dall’azienda Verisign Global Registry Services).\newline
	Per cui, contatta uno di questi server TLD che gli restituisce uno o più indirizzi IP del server autoritativo per \textsf{amazon.com}.\newline
	Infine, contatta uno dei server autoritativi per \textsf{amazon.com} che gli restituisce l’indirizzo IP dell’hostname \textsf{www.amazon.com}.
	
	\newpage
	
	\subsection{\textcolor{Red3}{Esercizio - Determinare CIDR e creare subnetting con condizioni}}
	
	Si consideri la seguente rete formata da 5 sottoreti. Due indirizzi sono già assegnati alla rete:
	
	\begin{equation*}
		101.75.79.255 \hspace{3em} 101.75.80.0
	\end{equation*}

	\noindent
	Determinare il blocco CIDR più piccolo che contiene tali indirizzi. Per “più piccolo” si intende con numero minore di indirizzi.\newline
	
	\noindent
	Una volta trovato il blocco CIDR, creare 5 sottoreti con i seguenti vincoli:
	
	\begin{itemize}
		\item LAN1: Deve avere un prefisso di /21
		\item LAN2: Deve ospitare fino a 1000 host
		\item LAN3: Deve avere un prefisso di /23
		\item LAN4: Deve ospitare fino a 400 host
		\item LAN5: Deve avere la metà degli indirizzi a disposizione del blocco di partenza
	\end{itemize}

	\noindent
	Inizialmente si traducono gli indirizzi che si hanno in binario:
	\begin{equation*}
		\begin{array}{lll}
			101.75.79.255	& \longrightarrow & \binaryaddresspointed{01100101}{01000011}{01001111}{11111111} \\
			101.75.80.0		& \longrightarrow & \binaryaddresspointed{01100101}{01000011}{01010000}{00000000}
		\end{array}
	\end{equation*}

	\noindent
	Per \textbf{calcolare il prefisso} basta prendere in considerazione i bit identici nei due indirizzi. Il conteggio prosegue finché non si trova un bit che differisce. Per cui, in questo esercizio il bit numero 20 differisce, infatti nel primo indirizzo è 0, mentre nel secondo è 1. In conclusione, il prefisso è $/19$. Ponendo i restanti ($2^{32} \div 2^{19} = 2^{13}$) 13 bit a zero, si ottiene l’indirizzo di rete:
	\begin{equation*}
		101.75.64.0/19
	\end{equation*}
	Che avrà a disposizione $2^{13}$ indirizzi, ovvero 8192 il quale rappresenta il \textbf{blocco CIDR}.\newline
	
	\noindent
	Adesso inizia il calcolo dei vari indirizzi delle LAN. La LAN numero 5 deve avere la metà degli indirizzi disponibili messi a disposizione dalla rete di partenza, ovvero quella appena trovata. Per cui si creano le prime sottoreti (\emph{subnetting}) assegnandone una alla LAN5 che avrà per cui il prefisso maggiorato di un bit e un numero di indirizzi disponibili pari a: $2^{32} \div 2^{20} = 2^{12} \rightarrow 4096$.\newline
	
	\noindent
	Quindi si creano le due sottoreti:
	\begin{equation*}
		\begin{array}{lll}
			\binaryaddresspointed{01100101}{01000011}{010\textcolor{Red3}{\boldsymbol{0}}0000}{00000000} & \longrightarrow & 101.75.64.0/20 \\
			\binaryaddresspointed{01100101}{01000011}{010\textcolor{Red3}{\boldsymbol{1}}0000}{00000000} & \longrightarrow & 101.75.80.0/20
		\end{array}
	\end{equation*}
	E si afferma che l’indirizzo $101.75.64.0/20$ è assegnato alla LAN5.\newline
	
	\noindent
	Dal secondo indirizzo si creano altre sottoreti per soddisfare il criterio della prima LAN:
	\begin{equation*}
		\begin{array}{lll}
			\binaryaddresspointed{01100101}{01000011}{0101\textcolor{Red3}{\boldsymbol{0}}000}{00000000} & \longrightarrow & 101.75.80.0/21 \\
			\binaryaddresspointed{01100101}{01000011}{0101\textcolor{Red3}{\boldsymbol{1}}000}{00000000} & \longrightarrow & 101.75.88.0/21
		\end{array}
	\end{equation*}
	E si afferma che l’indirizzo $101.75.80.0/21$ è assegnato alla LAN1.\newline
	
	\noindent
	A questo punto si può notare che la seconda LAN richiede almeno 1000 host. Per soddisfare questa richiesta si può fare un calcolo rapido e confermare il fatto che se venissero create altre sottoreti dall’indirizzo disponibile qui sopra ($101.75.88.0/21$), si verrebbe a creare una rete con un prefisso di 22, un suffisso di $32-22=10$ bit, ovvero $2^{10} = 1024$ indirizzi. Quindi:
	\begin{equation*}
		\begin{array}{lll}
			\binaryaddresspointed{01100101}{01000011}{01011\textcolor{Red3}{\boldsymbol{0}}00}{00000000} & \longrightarrow & 101.75.88.0/22 \\
			\binaryaddresspointed{01100101}{01000011}{01011\textcolor{Red3}{\boldsymbol{1}}00}{00000000} & \longrightarrow & 101.75.92.0/22
		\end{array}
	\end{equation*}
	E si afferma che l’indirizzo $101.75.88.0/22$ è assegnato alla LAN2.\newline
	
	\noindent
	Infine, costruendo altre due sottoreti dall’indirizzo disponibile si troverebbe il nuovo indirizzo disponibile per la rete LAN numero 3 e 4. La numero 3 sarebbe rispettata perché il prefisso passerebbe da 22 a 23, mentre la numero 4 avrebbe $32-23=9$ bit di suffisso, ovvero $2^{9}=512$ indirizzi disponibili.\newline
	Per concludere quindi:
	\begin{equation*}
		\begin{array}{lll}
			\binaryaddresspointed{01100101}{01000011}{010111\textcolor{Red3}{\boldsymbol{0}}0}{00000000} & \longrightarrow & 101.75.92.0/23 \\
			\binaryaddresspointed{01100101}{01000011}{010111\textcolor{Red3}{\boldsymbol{1}}0}{00000000} & \longrightarrow & 101.75.94.0/23
		\end{array}
	\end{equation*}
	E si afferma che l’indirizzo $101.75.92.0/23$ è assegnato alla LAN3, mentre l’indirizzo $101.75.94.0/23$ è assegnato alla LAN4.
	
	\newpage
	
	\section{Posta elettronica SMTP e livello di trasporto}
	
	\subsection{Posta elettronica}
	
	L’e-mail rappresenta un mezzo di comunicazione asincrono: le persone inviano e leggono messaggi nel momento per loro più opportuno, senza doversi coordinare con altri utenti. I grandi vantaggi della posta elettronica sono la velocità, la facilità di distribuzione e il prezzo, ovvero gratuito.\newline
	
	\noindent
	In questo argomento ci sono tre \textbf{componenti principali}:
	\begin{enumerate}
		\item \textbf{User agent} (o agenti utente) che sono per esempio Microsoft Outlook e Apple Mail, i quali consentono agli utenti di leggere, rispondere, inoltrare, salvare e comporre i messaggi.
		
		\item \textbf{Server di posta} (o \emph{mail server}) costituiscono la parte centrale dell’infrastruttura del servizio di posta elettronica. Ciascun destinatario ha una \textbf{casella di posta} (\emph{mailbox}) collocata in un mail server.\newline
		Può capitare che una volta inviato il messaggio, il server non possa consegnare la posta. In tal caso esso la trattiene in una \textbf{coda di messaggi} e cerca di trasferirla in un secondo momento. In caso di mancata consegna dopo alcuni giorni dall’invio del messaggio, il server rimuove il messaggio e avvisa il mittente con un messaggio di posta elettronica.
		
		\item \textbf{Protocollo SMTP} (\emph{Simple Mail Transfer Protocol}) rappresenta il principale protocollo a livello di applicazione per la posta elettronica su Internet. Utilizza TCP, quindi viene considerato un servizio di trasferimento dati affidabile.\newline
		Questo protocollo viene eseguito sia lato client, quando è in esecuzione sul server di posta del mittente, sia lato server, quando è in esecuzione sul server del destinatario.
	\end{enumerate}

	\newpage

	\subsection{Protocollo SMTP}
	
	Il \textcolor{Red3}{\textbf{protocollo SMTP}} si occupa di \textbf{trasferire i messaggi dal mail server del mittente a quello del destinatario}. Nonostante la sua fama, SMTP rappresenta una tecnologia ereditata con caratteristiche \dquotes{arcaiche}.\newline
	\textbf{Per esempio}, il corpo dei messaggi di posta li tratta come semplice codice ASCII a 7 bit. Questa restrizione aveva senso nei primi anni '80, quando la capacità trasmissiva era scarsa e nessuno inviava per posta elettronica grandi allegati quali immagini, audio o video, ma oggi la restrizione all’ASCII a 7 bit è piuttosto penalizzante, in quanto richiede che i dati multimediali binari vengano codificati in ASCII prima di essere inviati e che il messaggio venga nuovamente decodificato in binario dopo il trasporto.\newline
	
	\noindent
	Il protocollo SMTP è uno dei protagonisti principali nella comunicazione tra client e server. Per esempio, supponiamo che Alice voglia inviare a Bob un semplice messaggio ASCII:
	\begin{enumerate}
		\item Alice invoca il proprio \emph{user agent} per la posta elettronica, fornisce l’indirizzo di posta di Bob, compone il messaggio e dà istruzione allo \emph{user agent} di inviarlo.
		
		\item Lo \emph{user agent} di Alice invia il messaggio al suo \emph{mail server}, il quale colloca esso in una coda di messaggi.
		
		\item Il lato client di SMTP, eseguito sul server del mittente (Alice), vede il messaggio nella coda dei messaggi e apre una connessione TCP verso un server SMTP in esecuzione sul \emph{mail server} del destinatario (Bob).
		
		\item Dopo un \emph{handshaking} SMTP, il client SMTP invia il messaggio di Alice sulla connessione TCP.
		
		\item Il \emph{mail server} di Bob, il lato server di SMTP riceve il messaggio, che viene posizionato nel \emph{mail server} della casella postale di Bob.
		
		\item Bob, quando ritiene opportuno, invoca il proprio user agent per leggere il messaggio.
	\end{enumerate}
	Si noti che solitamente SMTP non usa \emph{mail server} intermedi. Ovvero, se il server del mittente si trova a Hong Kong e quello del destinatario a St. Louis, la connessione TCP ha luogo direttamente tra le due città. In particolare, se il \emph{mail server} del destinatario è spento, il messaggio rimane nel \emph{mail server} del mittente e attende un nuovo tentativo. Questo è il significato dell’affermazione \textbf{\dquotes{il messaggio non viene posizionato in alcun \emph{mail server} intermedio}}.\newline
	
	\noindent
	Nell’esempio si è visto come il \emph{client} SMTP (in esecuzione sul \emph{mail server} del mittente) fa stabilire a TCP una \textbf{connessione sulla porta 25} verso il server SMTP (in esecuzione sul \emph{mail server} del destinatario).\newline
	Una volta stabilita la connessione, il \emph{server} e il \emph{client} effettuano una qualche forma di \emph{handshaking} a livello applicativo, ovvero il \emph{client} inizialmente invia prima l’e-mail del mittente e solo dopo aver ricevuto un messaggio di avvenuta ricezione invia il secondo messaggio contenente l’e-mail del destinatario.\newline
	Dopo l’\emph{handshaking}, il \emph{client} invia il messaggio e ripete il processo sulla stessa connessione TCP se ha altri messaggi da inviare al \emph{server}, altrimenti ordina a TCP di chiudere la connessione.
	
	\subsection{Livello di trasporto}
	
	\subsubsection{Definizione}
	
	Un \textcolor{Red3}{\textbf{protocollo a livello}} di trasporto mette a disposizione una \textbf{comunicazione logica} tra processi applicativi di host differenti.\newline
	
	\noindent
	Per \textbf{comunicazione logica} si intende che tutto procede come se gli host che eseguono i processi fossero direttamente connessi. In realtà, gli host si possono trovare agli antipodi del pianeta ed essere connessi da numerosi router e da svariati tipi di collegamenti. Infatti, i processi applicativi usano la comunicazione logica fornita dal livello di trasporto per scambiare messaggi, senza preoccuparsi dei dettagli dell’infrastruttura fisica utilizzata per trasportarli.\newline
	
	\noindent
	Il \textbf{compito} del \textbf{livello di trasporto} è il seguente:
	\begin{itemize}
		\item \textbf{Lato \underline{mittente}:}
		\begin{enumerate}[label=\alph*)]
			\item Il livello di trasporto \textbf{converte i messaggi} che riceve da un processo applicativo in pacchetti a livello di trasporto, noti secondo la terminologia Internet come \textbf{segmenti} (\emph{transport-layer segment});
			\item Successivamente il livello di trasporto passa il segmento al livello di rete, dove viene \textbf{incapsulato all’interno di un pacchetto} a livello di rete (si chiamerà datagramma);
			\item Infine, il livello di rete lo invia a destinazione.
		\end{enumerate}
		
		\item \textbf{Lato \underline{destinatario}:}
		\begin{enumerate}[label=\alph*)]
			\item Il livello di rete \textbf{estrae il segmento} dal datagramma e lo passa al livello superiore, quello di trasporto;
			\item Il livello di trasporto \textbf{elabora il segmento} ricevuto, rendendo disponibili all'applicazione destinataria i dati del segmento.
		\end{enumerate}
	\end{itemize}

	\subsubsection{Protocolli usati}
	
	I protocolli utilizzati a livello di trasporto sono i due modelli già visti in passato: \textbf{UDP} (\emph{user datagram protocol}, capitolo~\ref{protocollo UDP}), che fornisce un servizio non affidabile e non orientato alla connessione, e \textbf{TCP} (\emph{transmission control protocol}, capitolo~\ref{protocollo TCP}), che offre un servizio affidabile e orientato alla connessione.
	
	\newpage
	
	\subsubsection{Struttura dei segmenti nei protocolli}
	
	Al livello di trasporto i due protocolli hanno due strutture diverse.\newline
	
	\noindent
	\textcolor{Red3}{\textbf{\underline{Protocollo UDP}}}\newline
	
	\noindent
	Nel protocollo UDP l'intestazione presenza solo quattro campi di due byte ciascuno, ovvero \textbf{16 bit ciascun campo}. L'intestazione occupa 8 byte.
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=0.7\textwidth]{img/segmento_udp.pdf}
		\caption{Struttura segmento nel protocollo UDP.}
	\end{figure}

	\noindent
	I \textbf{numeri di porta} consentono all’host di destinazione di trasferire i dati applicativi al processo corretto.\newline

	\noindent
	Il \textbf{campo lunghezza} specifica il numero di byte del segmento UDP (intestazione più dati). Un valore esplicito di lunghezza è necessario perché la grandezza del campo dati può essere diversa tra un segmento e quello successivo.\newline
	
	\noindent
	L'host ricevente utilizza il \textbf{checksum} per verificare se sono avvenuti errori nel segmento.
	
	\newpage
	
	\noindent
	\textcolor{Red3}{\textbf{\underline{Protocollo TCP}}}\newline
	
	\noindent
	Nel protocollo TCP il segmento è formato da campi intestazione e di un campo contenente un blocco di dati proveniente dall’applicazione. I campi intestazione formano in totale 20 byte, ovvero 12 in più rispetto a UDP.
	\begin{figure}[!htp]
		\centering
		\includegraphics[width=0.8\textwidth]{img/segmento_tcp.pdf}
		\caption{Struttura segmento nel protocollo TCP.}
	\end{figure}

	\noindent
	L'\textbf{intestazione} include:
	\begin{itemize}
		\item \textbf{Numeri di porta di origine} e \textbf{di destinazione}, utilizzati per il \emph{multiplexing} (processo di costruzione del messaggio) e \emph{demultiplexing} (processo di scomposizione del messaggio).
		
		\item Il campo \textbf{numero di sequenza} (\emph{sequence number}) e il campo \textbf{numero di acknowledgement} (\emph{acknowledgment number}), entrambi di 32 bit, vengono utilizzati dal mittente e dal destinatario TCP per implementare il trasferimento dati affidabile.
		
		\item Il campo \textbf{lunghezza dell'intestazione} (\emph{header length}), di 4 bit, specifica la lunghezza dell’intestazione TCP in multipli di 32 bit. L’intestazione TCP ha lunghezza variabile a causa del tempo delle opzioni TCP. Generalmente, il campo delle opzioni è vuoto e, pertanto, la lunghezza consueta è di 20 byte.
		
		\item Il campo \textbf{flag} (indicato con le lettere F nella figura) è di 6 bit:
		\begin{itemize}
			\item \textbf{ACK} viene usato per indicare che il valore trasportato nel campo di acknowledgement è valido, ovvero il segmento contiene un acknowledgement per un segmento che è stato ricevuto con successo.
			
			\item \textbf{RST, SYN, FIN} vengono utilizzati per impostare e chiudere la connessione.
			
			\item \textbf{CWR, ECE} sono usati nel controllo di congestione esplicito.
			
			\item \textbf{PSH} se ha il valore 1 vuol dire che il destinatario dovrebbe inviare immediatamente i dati al livello superiore.
			
			\item \textbf{URG} indica che il segmento presenta dati che sono stati marcati \dquotes{urgenti} dal livello superiore (solo il mittente ha questa possibilità).
		\end{itemize}
	
		\item Il campo \textbf{finestra di ricezione} (\emph{receive window}), di 16 bit, viene utilizzato per il controllo di flusso, ovvero per indicare il numero di byte che il destinatario è disposto ad accettare.
		
		\item Il campo \textbf{checksum} di 16 bit è utilizzato per rilevare errori sui bit in un pacchetto trasmesso.
		
		\item Il campo \textbf{puntatore ai dati urgenti} è di 16 bit. Quando ci sono dati urgenti, TCP deve informare l’entità destinataria al livello superiore e passarle un puntatore alla fine dei dati urgenti.
		
		\item Il campo \textbf{opzioni} (\emph{options}) è facoltativo e di lunghezza variabile. Viene utilizzato quando mittente e destinatario negoziano la dimensione massima del segmento (\emph{Maximum Segment Size}) o come fattore di scala per la finestra nelle reti ad alta velocità.
	\end{itemize}
	La massima quantità di dati prelevabili e posizionabili in un segmento viene limitata dalla \textcolor{Red3}{\textbf{dimensione massima di segmento}} (MSS, \emph{maximum segment size}). Questo valore viene generalmente impostato determinando prima la lunghezza del frame più grande che può essere inviato a livello di collegamento dall’host mittente locale, ovvero la cosiddetta \textcolor{Red3}{\textbf{unità trasmissiva massima}} (MTU, \emph{maximum transmission unit}).\newline
	
	\noindent
	I \textbf{campi} presenti all’interno del TCP hanno delle porte. I numeri di porta sono di 16 bit e vanno da 0 a 65535, quelli che vanno da 0 a 1023 sono chiamati \textbf{numeri di porta noti} (\emph{well-know port number}) e sono riservati per essere usati da protocolli applicativi ben noti quali HTTP (porta 80) e FTP (porta 21). (l’elenco dei numeri di porta noti è fornito nell’RFC 1700, la sua versione aggiornata si trova al link: \href{http://www.iana.org}{iana.org})\newline
	
	\noindent
	Il \textbf{numero di sequenza per un segmento} è il numero nel flusso di byte del primo byte di segmento. Per esempio, supponiamo che un processo nell’Host A voglia inviare un flusso di dati a un processo sull’Host B su una connessione TCP. TCP sull’Host A numera implicitamente ogni byte del flusso di dati. Ipotizziamo che il flusso di dati consista in un file da 500'000 byte, che la MSS valga 1000 byte e che il primo byte del flusso sia numerato con 0. TCP costruisce 500 segmenti per questo flusso di dati ($500'000 \div 1000$). Al primo segmento viene assegnato numero di sequenza 0, al secondo 1000, al terzo 2000 e così via. Ogni numero di sequenza viene inserito nel campo numero di sequenza dell’intestazione del segmento TCP appropriato. Il numero di acknowledgement che l’Host A scrive nei propri segmenti è il numero di sequenza del byte successivo che l’Host A attende dall’Host B. Facciamo alcuni esempi.\newline
	
	\noindent
	Supponiamo che l’Host A abbia ricevuto da B tutti i byte numerati da 0 a 535 e che A stia per mandare un segmento all’Host B. L’Host A è in attesa del byte 536 e dei successivi byte nel flusso di dati di B. pertanto, l’Host A scrive 536 nel campo del numero di acknowledgement del segmento che spedisce a B.\newline
	
	\noindent
	Un ulteriore esempio. Supponiamo che l’Host A abbia ricevuto un segmento dall’Host B contenente i byte da 0 a 535 e un altro segmento contenente i byte da 900 a 1000. Per qualche motivo l’Host A non ha ancora ricevuto i byte da 536 a 899. In questo esempio, l’Host A sta ancora attendendo il byte 536 (e i successivi) per ricreare il flusso di dati di B. perciò il prossimo segmento di A destinato a B conterrà 536 nel campo del numero di acknowledgement. Dato che TCP effettua l’acknowledgement solo dei byte fino al primo byte mancante nel flusso, si dice che tale protocollo offre \textbf{acknowledgement cumulativi} (\emph{cumulative acknowledgement}).
\end{document}